<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://guohui8.github.io">
  <title>Guohui的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="程序媛鼓励师、精神慈善家、装逼爱好者。">
<meta property="og:type" content="website">
<meta property="og:title" content="Guohui的博客">
<meta property="og:url" content="https://guohui8.github.io/page/4/index.html">
<meta property="og:site_name" content="Guohui的博客">
<meta property="og:description" content="程序媛鼓励师、精神慈善家、装逼爱好者。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Guohui的博客">
<meta name="twitter:description" content="程序媛鼓励师、精神慈善家、装逼爱好者。">
  
    <link rel="alternative" href="/atom.xml" title="Guohui的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.234bc0.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #0DC7F5"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/a.png" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Guohui</a></h1>
		</hgroup>
		
		<p class="header-subtitle">随心而动 随刃而行</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/技术/">技术</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
				<li><a href="/tags/相册/">相册</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/guohui8" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://www.weibo.com/p/1005052938547113" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="qq" target="_blank" href="http://sighttp.qq.com/msgrd?v=1&uin=1207509097" title="qq"><i class="icon-qq"></i></a>
		        
					<a class="weixin" target="_blank" href="#" title="weixin"><i class="icon-weixin"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:1207509097@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #0DC7F5"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/a.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Guohui</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>随心而动 随刃而行<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/guohui8" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://www.weibo.com/p/1005052938547113" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="qq" target="_blank" href="http://sighttp.qq.com/msgrd?v=1&uin=1207509097" title="qq"><i class="icon-qq"></i></a>
			        
						<a class="weixin" target="_blank" href="#" title="weixin"><i class="icon-weixin"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:1207509097@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/tags/技术/">技术</a></li>
		        
					<li style="width: 25%"><a href="/tags/随笔/">随笔</a></li>
		        
					<li style="width: 25%"><a href="/tags/相册/">相册</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Javascript基础总结七(Ajax+http）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/Javascript基础总结七(Ajax+http）/">Javascript基础总结七(Ajax+http）</a>
    </h1>
  

        
        <a href="/2016/03/20/Javascript基础总结七(Ajax+http）/" class="archive-article-date">
  	<time datetime="2016-03-20T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-20</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Ajax及其工作原理"><a href="#Ajax及其工作原理" class="headerlink" title="Ajax及其工作原理"></a>Ajax及其工作原理</h2><p>AJAX 是一种与服务器交换数据无需刷新网页的技术，最早由Google公司在谷歌地图里使用，并迅速风靡。</p>
<p>AJAX是不能跨域的，如需跨域，可以使用<code>document.domain=&#39;a.com&#39;；</code>或者使用服务器代理，代理XMLHttpRequest文件</p>
<p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest 对象 (异步的与服务器交换数据)</div><div class="line">JavaScript/DOM (信息显示/交互)</div><div class="line">CSS (给数据定义样式)</div><div class="line">XML (作为转换数据的格式)</div></pre></td></tr></table></figure>
<p><img src="https://segmentfault.com/img/bVc36v" alt="img"></p>
<h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 <code>XMLHttpRequest</code> 对象。</p>
<p><strong>创建Ajax对象：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//IE6以上</div><div class="line">var oAjax = new XMLHttpRequest();</div><div class="line"></div><div class="line">//IE6</div><div class="line">var oAjax =new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</div></pre></td></tr></table></figure>
<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oAjax.open(方法,url,是否异步)</div></pre></td></tr></table></figure>
<p>我们都知道，Ajax即“<code>Asynchronous Javascript And XML</code>”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。所以，Ajax天生就是工作在异步模式的（异步为true，同步false）</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。<br>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</p>
<h2 id="发送请求send"><a href="#发送请求send" class="headerlink" title="发送请求send()"></a>发送请求send()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function getDoc()&#123;</div><div class="line">    var xmlhttp;</div><div class="line">    if(window.xmlhttpRequest)&#123;</div><div class="line">        xmlhttp=new XMLHttpRequest();</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//for IE6</div><div class="line">    &#125;</div><div class="line">    xmlhttp.onreadystatechange = function()&#123;</div><div class="line">        if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123;</div><div class="line">            document.getElementById(&quot;￼myId&quot;).innerHTML=xmlhttp.responseText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    xmlhttp.open(&quot;￼GET&quot;, index.php,true);</div><div class="line">    xmlhttp.send();</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;button type=&quot;button&quot; onclick=&quot;getDoc()&quot;&gt;请求数据&lt;/button&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p><strong>GET 还是 POST？</strong></p>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">无法使用缓存文件（更新服务器上的文件或数据库）</div><div class="line">向服务器发送大量数据（POST 没有数据量限制）</div><div class="line">发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</div></pre></td></tr></table></figure>
<h2 id="接收返回信息"><a href="#接收返回信息" class="headerlink" title="接收返回信息"></a>接收返回信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">oAjax.onreadystatechange = function()&#123;   //当请求状态改变时要调用的事件处理器</div><div class="line"></div><div class="line">    alert(oAjax.readystate);           </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>只要<code>readyState</code>属性的值发生变化时，便会触发一次<code>readyStatechange</code>事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪，不过，必须在调用<code>open()</code>之前指定<code>onreadystatechange</code>事件处理程序才能确保跨浏览器兼容性。下面来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var xhr = createXHR();</div><div class="line">xhr.onreadystatechange = function () &#123;</div><div class="line">    if (xhr.readyState == 4) &#123;</div><div class="line">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class="line">            alert(xhr.statusText);</div><div class="line">        &#125; else &#123;</div><div class="line">            alert(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure>
<h3 id="XHR对象"><a href="#XHR对象" class="headerlink" title="XHR对象"></a>XHR对象</h3><p><code>XMLHttpRequest</code>这个对象的属性：</p>
<p><strong>它的属性有：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">onreadystatechange  每次状态改变所触发事件的事件处理程序。</div><div class="line"></div><div class="line">responseText     从服务器进程返回数据的字符串形式。</div><div class="line">responseXML    从服务器进程返回的DOM兼容的文档数据对象。</div><div class="line"></div><div class="line">status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</div><div class="line"></div><div class="line">status Text       伴随状态码的字符串信息</div></pre></td></tr></table></figure>
<p>当XHR对象把一个HTTP请求发送到服务器的过程中会经历几个状态，直到请求被处理，然后才接收一个回应。<code>readyState</code>就是XHR请求的状态属性，它本身有5个属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0（未初始化）还没有调用open()方法</div><div class="line">1（载入）已调用send()方法，正在发送请求</div><div class="line">2(载入完成)send()方法完成，已收到全部响应内容</div><div class="line">3(解析)正在解析响应内容</div><div class="line">4（完成）响应内容解析完成，可以再客户端使用了</div></pre></td></tr></table></figure>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p><strong>1字头：</strong>消息。这一类型的状态码，代表请求已被接受，需要继续处理。<br><strong>2字头：</strong>成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<br><strong>3字头：</strong><a href="http://segmentfault.com/blog/trigkit4/1190000000682468#articleHeader2" target="_blank" rel="external">重定向</a>。这类状态码代表需要客户端采取进一步的操作才能完成请求。<br><strong>4字头：</strong>客户端错误。这类状态码代表了客户端看起来可能发生错误，妨碍了服务器的处理。<br><strong>5字头</strong>：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p><strong>另附：</strong><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="external">http状态码详解</a><br>w3cschool HTTP 状态消息：<a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="external">http://www.w3school.com.cn/ta…</a></p>
<p><img src="https://segmentfault.com/img/bVdezN" alt="img"></p>
<h2 id="status和statusText"><a href="#status和statusText" class="headerlink" title="status和statusText"></a>status和statusText</h2><p>　　<code>statusText</code>是响应返回的文本信息，仅当<code>readyState</code>值为3或4的时候才能使用。当<code>readyState</code>为其它值时视图存取<code>statusText</code>属性将引发异常。</p>
<h2 id="XHR的方法"><a href="#XHR的方法" class="headerlink" title="XHR的方法"></a>XHR的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abort()</td>
<td>导致当前正在执行的请求被取消</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>返回包含所有响应头的名称和值的单个字符</td>
</tr>
<tr>
<td>getResponseHeader(name)</td>
<td>返回响应头中指定的名称和值</td>
</tr>
<tr>
<td>open(method,url,async,username,pwd)</td>
<td>设置HTTP方法（get或post）等</td>
</tr>
<tr>
<td>send(content)</td>
<td>发出带有指定主体内容的请求</td>
</tr>
<tr>
<td>setRequestHeader(name,value)</td>
<td>使用指定的名称和值设置请求头</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        var oAjax =oAjax();</div><div class="line">        alert(oAjax.readyState);//弹出&quot;0&quot;</div><div class="line">        oAjax.open(&quot;get&quot;,&quot;index.html&quot;,true);</div><div class="line">        alert(oAjax.readyState);//弹出&quot;1&quot;</div><div class="line">        oAjax.send(null);</div><div class="line">        alert(oAjax.readyState);//IE下弹出4,而firefox是2</div><div class="line">        //可以通过readystatechange事件监听</div><div class="line">        oAjax = XHR();</div><div class="line">        oAjax.onreadystatechange = function () &#123;</div><div class="line">            alert(oAjax.readyState);//Firefox下依次是1,2,3,4但最后还会再来个1</div><div class="line">            //IE下则是1,1,3,4</div><div class="line">        &#125;;</div><div class="line">        oAjax.open(&quot;get&quot;,&quot;index.txt&quot;,true);</div><div class="line">        oAjax.send(null);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2><p><code>.load()</code>方法是局部方法，因为他需要一个包含元素的<code>jQuery</code>对象作为前缀，而<code>$.get()</code>和<code>$.post()</code>是全局方法，无需指定某个元素，对于用途而言，<code>.load()</code>适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，<code>$.get()</code>和<code>$.post()</code>更加合适。</p>
<p>GET和POST传入的data是一个键值对 对象，不同的是GET传入的data是通过地址栏传输的，而POST是通过表单提交的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line">    $(&quot;input&quot;).click(function () &#123;</div><div class="line">        $.get(&apos;test.php?url=baidu.com&apos;, function (response,status,xhr) &#123;</div><div class="line">            $(&apos;#box&apos;).html(response);</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>POST</code>提交不能使用<code>url</code>传参。<code>post</code>提交可以使用字符串形式的键值对形式传参，自动转换为http消息实体传参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line">    $(&quot;input&quot;).click(function () &#123;</div><div class="line">        $.post(&apos;test.php&apos;,&apos;url=baidu.com&apos;, function (response,status,xhr) &#123;</div><div class="line">            $(&apos;#box&apos;).html(response);</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//post提交可以使用对象键值对</div><div class="line"></div><div class="line">$(function () &#123;</div><div class="line">    $(&quot;input&quot;).click(function () &#123;</div><div class="line">        $.post(&apos;test.php&apos;,&#123;</div><div class="line">                url:&apos;baidu.com&apos;//post提交可以使用对象键值对</div><div class="line">            &#125;, function (response,status,xhr) &#123;</div><div class="line">            $(&apos;#box&apos;).html(response);</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>$.get()</code>方法有四个参数，前面三个参数和<code>.load()</code>一样，多了一个第四参数<code>type</code>，即服务器返回的内容格式，包括<code>xml,json,script,html,text</code>等，第一个参数为必选参数，后面三个为可选参数</p>
<p><code>$.ajax()</code>是所有Ajax方法中最底层的方法，所有其他方法都是基于<code>$.ajax()</code>方法的封装，这个方法只有一个参数，传递一个<br>各个功能键值对的对象。</p>
<h3 id="ajax-方法对象参数列表"><a href="#ajax-方法对象参数列表" class="headerlink" title="$.ajax()方法对象参数列表"></a>$.ajax()方法对象参数列表</h3><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>string</td>
<td>发送请求的地址</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>请求方法，默认GET</td>
</tr>
<tr>
<td>timeout</td>
<td>Number</td>
<td>设置请求超时的时间</td>
</tr>
<tr>
<td>data</td>
<td>Object或String</td>
<td>发送到服务器的对象，键值对字符串或对象</td>
</tr>
<tr>
<td>datatype</td>
<td>String</td>
<td>返回的数据类型，比如html，XML，json等</td>
</tr>
<tr>
<td>success</td>
<td>Function</td>
<td>请求成功后调用的回调函数</td>
</tr>
<tr>
<td>complete</td>
<td>Function</td>
<td>请求完成后调用的回调函数</td>
</tr>
<tr>
<td>error</td>
<td>Function</td>
<td>请求失败后调用的回调函数</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line">    $(&quot;input&quot;).click(function () &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            type : &quot;POST&quot;,</div><div class="line">            url: &apos;test.php&apos;,</div><div class="line">            data:&#123;</div><div class="line">                url: &apos;baidu.com&apos;</div><div class="line">            &#125;,</div><div class="line">            success : function(response,status,xhr)&#123;</div><div class="line">                $(&apos;#box&apos;).html(response);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h3><p><code>Ajax</code>用的最多的地方莫过于表单操作，而传统的表单操作是通过<code>submit</code>提交将数据传输到服务器，如果使用<code>Ajax</code>异步处理<br>的话，我们需要将每个表单元素获取才能提交，这样工作效率就大大降低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;form action=&quot;&quot;&gt;</div><div class="line">    用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;</div><div class="line">    邮件: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    $(function () &#123;</div><div class="line">        $(&quot;form input[type=button]&quot;).click(function () &#123;</div><div class="line">            $.ajax(&#123;</div><div class="line">                type: &apos;POST&apos;,</div><div class="line">                url: &apos;test.php&apos;,</div><div class="line">                data: &#123;</div><div class="line">                    user: $(&apos;form input[name=user]&apos;).val(),</div><div class="line">                    email: $(&quot;form input[name=email]&quot;).val(),</div><div class="line">                &#125;,</div><div class="line">                success: function(response)&#123;</div><div class="line">                    $(&quot;#box&quot;).html(response);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>表单元素特别多的情况下应采用表单序列化，即<code>data:$(“form”).serialize();</code>//得到的是字符串键值对，并且对<code>url</code>进行编码</p>
<p><code>serialize()</code>方法不但可以序列化表单内的元素，还可以直接获取单选框，复选框和下拉列表框等内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;form action=&quot;&quot;&gt;</div><div class="line">    用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;</div><div class="line">    邮件: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;</div><div class="line">    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt;男</div><div class="line">    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt;女</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;submit&quot;/&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    $(function () &#123;</div><div class="line">        $(&quot;form input[name=sex]&quot;).click(function () &#123;</div><div class="line">            $(&apos;#box&apos;).html(decodeURIComponent($(this).serialize()));</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h2 id="传统Ajax问题"><a href="#传统Ajax问题" class="headerlink" title="传统Ajax问题"></a>传统Ajax问题</h2><p>传统的<code>ajax</code>有如下的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1、可以无刷新改变页面内容，但无法改变页面URL</div><div class="line"></div><div class="line">2、为了更好的可访问性，内容发生改变后，通常改变URL的hash</div><div class="line"></div><div class="line">3、hash的方式不能很好的处理浏览器的前进、后退等问题</div><div class="line"></div><div class="line">4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变</div><div class="line"></div><div class="line">5、但这种方式对搜索引擎很不友好</div><div class="line"></div><div class="line">6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/20/Javascript基础总结七(Ajax+http）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结六(数据类型和Json）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/Javascript基础总结六(数据类型和Json）/">Javascript基础总结六(数据类型和Json）</a>
    </h1>
  

        
        <a href="/2016/03/18/Javascript基础总结六(数据类型和Json）/" class="archive-article-date">
  	<time datetime="2016-03-18T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-18</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p><code>JSON</code>：JavaScript 对象表示法（<code>J</code>ava<code>S</code>cript <code>O</code>bject <code>N</code>otation）。</p>
<p><code>JSON</code>的形式是用大括号<code>“{}”</code>包围起来的项目列表，每一个项目间用逗号（,）分隔，而项目就是用冒号（:）分隔的属性名和属性值。这是典型的字典表示形式，也再次表明<code>javascript</code>里的对象就是字典结构。不管多么复杂的对象，都可以用一句<code>JSON</code>代码来创建并赋值。在<code>JSON</code>中，名称/值对 包括字段名称（在双引号中），后面写一个冒号，然后是值</p>
<h2 id="JSON-结构"><a href="#JSON-结构" class="headerlink" title="JSON 结构"></a>JSON 结构</h2><p>JSON有两种结构</p>
<p><code>json</code>简单说就是<code>javascript</code>中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构</p>
<p><strong>1、对象</strong>：对象在js中表示为<code>“{}”</code>括起来的内容，数据结构为 <code>{key：value,key：value,...}</code>的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象<code>.key</code> 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。</p>
<p><strong>2、数组：</strong>数组在js中是中括号<code>“[]”</code>括起来的内容，数据结构为 <code>[&quot;java&quot;,&quot;javascript&quot;,&quot;vb&quot;,...]</code>，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。<br>经过对象、数组2种结构就可以组合成复杂的数据结构了。</p>
<h2 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a><strong>JSON 语法规则</strong></h2><p><code>JSON</code> 语法是 <code>JavaScript</code> 对象表示法语法的子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">数据在名称/值对中</div><div class="line">数据由逗号分隔</div><div class="line">花括号保存对象</div><div class="line">方括号保存数组</div></pre></td></tr></table></figure>
<p><code>JSON</code> 值可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">数字（整数或浮点数）</div><div class="line">字符串（在双引号中）</div><div class="line">逻辑值（true 或 false）</div><div class="line">数组（在方括号中）</div><div class="line">对象（在花括号中）</div><div class="line">null</div></pre></td></tr></table></figure>
<p>除以上6种外，再无其他，没有像js一样的undefined、NAN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1） 并列的数据之间用逗号（&quot;, &quot;）分隔。</div><div class="line"></div><div class="line">2） 映射用冒号（&quot;: &quot;）表示。</div><div class="line"></div><div class="line">3） 并列数据的集合（数组）用方括号(&quot;[]&quot;)表示。</div><div class="line"></div><div class="line">4） 映射的集合（对象）用大括号（&quot;&#123;&#125;&quot;）表示。</div></pre></td></tr></table></figure>
<p>对象是一套无序的名/值对，一个对象以左边分支开始，以右边分支结束<br><img src="http://segmentfault.com/img/bVcXW0" alt="img"></p>
<p>一个值可以是用双引号括起来的字符串，或者是一个数值，一个<code>true or false</code> ，一个数组或者一个对象<br><img src="http://segmentfault.com/img/bVcXW5" alt="img"></p>
<h2 id="JSON与对象字面量"><a href="#JSON与对象字面量" class="headerlink" title="JSON与对象字面量"></a>JSON与对象字面量</h2><p>在编程语言中,字面量是一种表示值的记法。<br><code>JSON</code>规定键-值对中的<code>键</code>必须用双引号！ 引号。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;first name&quot; : &quot;Mike&quot;&#125;;</div></pre></td></tr></table></figure>
<p>在<code>JSON</code>字符串中，不能使用函数或者正则表达式字面量</p>
<h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a><strong>数据类型：</strong></h2><p>从结构上看，所有的数据（data）最终都可以分解成三种类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如&quot;北京&quot;这个单独的词。</div><div class="line"></div><div class="line">第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如&quot;北京，上海&quot;。</div><div class="line"></div><div class="line">第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如&quot;首都：北京&quot;。</div></pre></td></tr></table></figure>
<p>在编程语言中，只要有了数组（array）和对象（object）就能够储存一切数据了。</p>
<p>数组和对象的另一个区别是，数组的数据没有”名称”（name），对象的数据有”名称”（name）。</p>
<p><code>JavaScript</code>中有5种简单数据类型（也称为基本数据类型）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>。还有1种复杂数据类型——<code>Object</code>，<code>Object</code>本质上是由一组无序的名值对组成的。</p>
<p>对一个值使用<code>typeof</code>操作符可能返回下列某个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;undefined&quot;——如果这个值未定义；</div><div class="line"></div><div class="line">&quot;boolean&quot;——如果这个值是布尔值；</div><div class="line"></div><div class="line">&quot;string&quot;——如果这个值是字符串；</div><div class="line"></div><div class="line">&quot;number&quot;——如果这个值是数值；</div><div class="line"></div><div class="line">&quot;object&quot;——如果这个值是对象或null；</div><div class="line"></div><div class="line">&quot;function&quot;——如果这个值是函数；</div></pre></td></tr></table></figure>
<h3 id="Undefined类型："><a href="#Undefined类型：" class="headerlink" title="Undefined类型："></a>Undefined类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    `Undefined`类型只有一个值，在使用var声明变量但未对其加以初始化时，</div><div class="line">这个变量的值就是undefined</div></pre></td></tr></table></figure>
<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>　　Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回”object”的原因，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var car = null;</div><div class="line">alert(typeof car); // &quot;object&quot;</div></pre></td></tr></table></figure>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>　　这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>　　<code>String</code>类型用于表示由零或多个16位<code>Unicode</code>字符组成的字符序列，即字符串。字符串可以由单引号(‘)或双引号(“)表示。</p>
<p>数值、布尔值、对象和字符串值都有<code>toString()</code>方法。但<code>null</code>和<code>undefined</code>值没有这个方法。</p>
<p>　　多数情况下，调用<code>toString()</code>方法不必传递参数。但是，在调用数值的<code>toString()</code>方法时，可以传递一个参数：输出数值的基数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());      //&quot;10&quot;</div><div class="line">alert(num.toString(2));     //&quot;1010&quot;</div><div class="line">alert(num.toString(8));     //&quot;12&quot;</div><div class="line">alert(num.toString(10));    //&quot;10&quot;</div><div class="line">alert(num.toString(16));    //&quot;a&quot;</div></pre></td></tr></table></figure>
<p>在不知道要转换的值是不是<code>null</code>或<code>undefined</code>的情况下，还可以使用转型函数<code>String()</code>，这个函数能够将任何类型的值转换为字符串。<code>String()</code>函数遵循下列转换规则：</p>
<p>　　● 如果值有<code>toString()</code>方法，则调用该方法（没有参数）并返回相应的结果</p>
<p>　　● 如果值是<code>null</code>，则返回”<code>null</code>“</p>
<p>　　● 如果值是<code>undefined</code>，则返回”<code>undefined</code>“</p>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>　　对象其实就是一组数据和功能的集合。对象可以通过执行<code>new</code>操作符后跟要创建的对象类型的名称来创建。而创建<code>Object</code>类型的实例并为其添加属性和（或）方法，就可以创建自定义对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div></pre></td></tr></table></figure>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var s = &quot;Nicholas&quot;;</div><div class="line">    var b =true;</div><div class="line">    var c = 21;</div><div class="line">    var u;</div><div class="line">    var n = null;</div><div class="line">    var o = &#123;&#125;;</div><div class="line">    var obj = new Object;//最好写出new object()形式</div><div class="line"></div><div class="line">    alert(typeof s);//string</div><div class="line">    alert(typeof b);//boolean</div><div class="line">    alert(typeof c);//number</div><div class="line">    alert(typeof u);//undefined</div><div class="line">    alert(typeof n);//object</div><div class="line">    alert(typeof o);//object</div><div class="line">    alert(typeof obj);//object</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/18/Javascript基础总结六(数据类型和Json）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结五（原型和原型链）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/Javascript基础总结五（原型和原型链）/">Javascript基础总结五（原型和原型链）</a>
    </h1>
  

        
        <a href="/2016/03/15/Javascript基础总结五（原型和原型链）/" class="archive-article-date">
  	<time datetime="2016-03-15T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-15</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="私有变量和函数"><a href="#私有变量和函数" class="headerlink" title="私有变量和函数"></a>私有变量和函数</h2><p>在函数内部定义的变量和函数，如果不对外提供接口，外部是无法访问到的，也就是该函数的私有的变量和函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Box()&#123;</div><div class="line">        var color = &quot;blue&quot;;//私有变量</div><div class="line">        var fn = function() //私有函数</div><div class="line">        &#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样在函数对象<code>Box</code>外部无法访问变量<code>color</code>和<code>fn</code>，他们就变成私有的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = new Box();</div><div class="line">    alert(obj.color);//弹出 undefined</div><div class="line">    alert(obj.fn);//同上</div></pre></td></tr></table></figure>
<h2 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数</h2><p>当定义一个函数后通过点号 <code>“.”</code>为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为<code>静态变量</code>和<code>静态函数</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Obj()&#123;&#125;;</div><div class="line"></div><div class="line">    Obj.num = 72;//静态变量</div><div class="line">    Obj.fn = function()  //静态函数</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    alert(Obj.num);//72</div><div class="line">    alert(typeof Obj.fn)//function</div><div class="line">    </div><div class="line">    var t = new Obj();</div><div class="line">    alert(t.name);//undefined</div><div class="line">    alert(typeof t.fn);//undefined</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="实例变量和函数"><a href="#实例变量和函数" class="headerlink" title="实例变量和函数"></a>实例变量和函数</h2><p>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，<code>js</code>也能做到这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">          function Box()&#123;</div><div class="line">                this.a=[]; //实例变量</div><div class="line">                this.fn=function()&#123; //实例方法</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            console.log(typeof Box.a); //undefined</div><div class="line">            console.log(typeof Box.fn); //undefined</div><div class="line">            </div><div class="line">            var box=new Box();</div><div class="line">            console.log(typeof box.a); //object</div><div class="line">            console.log(typeof box.fn); //function</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>为实例变量和方法添加新的方法和属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function Box()&#123;</div><div class="line">                this.a=[]; //实例变量</div><div class="line">                this.fn=function()&#123; //实例方法</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            var box1=new Box();</div><div class="line">            box1.a.push(1);</div><div class="line">            box1.fn=&#123;&#125;;</div><div class="line">            console.log(box1.a); //[1]</div><div class="line">            console.log(typeof box1.fn); //object</div><div class="line"></div><div class="line">            var box2=new Box();</div><div class="line">            console.log(box2.a); //[]</div><div class="line">            console.log(typeof box2.fn); //function</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在<code>box1</code>中修改了<code>a</code>和<code>fn</code>，而在<code>box2</code>中没有改变，由于数组和函数都是对象，是引用类型，这就说明<code>box1</code>中的属性和方法与<code>box2</code>中的属性与方法虽然同名但却不是一个引用，而是对<code>Box</code>对象定义的属性和方法的一个复制。</p>
<p>这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，<code>prototype</code>应运而生。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们创建的每个函数都有一个<code>prototype</code>属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，<code>prototype</code>就是通过调用<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader10" target="_blank" rel="external">构造函数</a>而创建的那个对象实例的原型对象。</p>
<p>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p>
<p>在<code>JavaScript</code>中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 <code>prototype</code> ,我们通常称之为原型。原型的值可以是一个对象,也可以是<code>null</code>。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为<code>原型链</code>。</p>
<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>函数可以用来作为构造函数来使用。另外只有函数才有prototype属性并且可以访问到，但是对象实例不具有该属性，只有一个内部的不可访问的<code>__proto__</code>属性。<code>__proto__</code>是对象中一个指向相关原型的神秘链接。按照标准，<code>__proto__</code>是不对外公开的，也就是说是个私有属性，但是Firefox的引擎将他暴露了出来成为了一个共有的属性，我们可以对外访问和设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var Browser = function()&#123;&#125;;</div><div class="line">    Browser.prototype.run = function()&#123;</div><div class="line">        alert(&quot;I&apos;m Gecko,a kernel of firefox￼&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var Bro = new Browser();</div><div class="line">    Bro.run();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>当我们调用<code>Bro.run()</code>方法时，由于<code>Bro</code>中没有这个方法，所以，他就会去他的<code>__proto__</code>中去找，也就是<code>Browser.prototype</code>，所以最终执行了该run()方法。（在这里，函数首字母大写的都代表构造函数，以用来区分普通函数）</p>
<p>当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（<code>__proto__</code>）指向构造函数的<code>prototype</code>，这个连接存在于实例和构造函数的<code>prototype</code>之间，而不是实例与构造函数之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function Person(name)&#123;                             //构造函数</div><div class="line">                this.name=name;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Person.prototype.printName=function() //原型对象</div><div class="line">            &#123;</div><div class="line">                alert(this.name);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            var person1=new Person(&apos;Byron&apos;);//实例化对象</div><div class="line">            console.log(person1.__proto__);//Person</div><div class="line">            console.log(person1.constructor);//自己试试看会是什么吧</div><div class="line">            console.log(Person.prototype);//指向原型对象Person</div><div class="line">            var person2=new Person(&apos;Frank&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><code>Person</code>的实例person1中包含了name属性，同时自动生成一个<code>__proto__</code>属性，该属性指向Person的prototype，可以访问到<code>prototype</code>内定义的<code>printName</code>方法，大概就是这个样子的:</p>
<p><img src="https://segmentfault.com/img/bVc8tG" alt="img"><br>　每个<code>JavaScript</code>函数都有<code>prototype</code>属性，这个属性引用了一个对象，这个对象就是原型对象。原型对象初始化的时候是空的，我们可以在里面自定义任何属性和方法，这些方法和属性都将被该构造函数所创建的对象继承。</p>
<p>那么，现在问题来了。构造函数、实例和原型对象三者之间有什么关系呢？</p>
<h2 id="构造函数、实例和原型对象的区别"><a href="#构造函数、实例和原型对象的区别" class="headerlink" title="构造函数、实例和原型对象的区别"></a>构造函数、实例和原型对象的区别</h2><p>实例就是通过构造函数创建的。实例一创造出来就具有<code>constructor</code>属性（指向构造函数）和<code>__proto__</code>属性（指向原型对象），</p>
<p>构造函数中有一个<code>prototype</code>属性，这个属性是一个指针，指向它的原型对象。</p>
<p>原型对象内部也有一个指针（<code>constructor</code>属性）指向构造函数:<code>Person.prototype.constructor = Person;</code></p>
<p>实例可以访问原型对象上定义的属性和方法。</p>
<p>在这里person1和person2就是实例，<code>prototype</code>是他们的原型对象。</p>
<p><strong>再举个栗子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Animal(name)   //积累构造函数</div><div class="line">    &#123;</div><div class="line">        this.name = name;//设置对象属性</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Animal.prototype.behavior = function() //给基类构造函数的prototype添加behavior方法</div><div class="line">    &#123;  </div><div class="line">        alert(&quot;this is a &quot;+this.name);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var Dog = new Animal(&quot;dog&quot;);//创建Dog对象</div><div class="line">    var Cat = new Animal(&quot;cat&quot;);//创建Cat对象</div><div class="line">    </div><div class="line">    Dog.behavior();//通过Dog对象直接调用behavior方法</div><div class="line">    Cat.behavior();//output &quot;this is a cat&quot;</div><div class="line">    </div><div class="line">    alert(Dog.behavior==Cat.behavior);//output true;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>可以从程序运行结果看出，<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader10" target="_blank" rel="external">构造函数</a>的<code>prototype</code>上定义的方法确实可以通过对象直接调用到，而且代码是共享的。（可以试一下将<code>Animal.prototype.behavior</code> 中的<code>prototype</code>属性去掉，看看还能不能运行。）在这里，prototype属性指向Animal对象。</p>
<h2 id="数组对象实例"><a href="#数组对象实例" class="headerlink" title="数组对象实例"></a>数组对象实例</h2><p>再看个数组对象的实例。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var array1 = [1,2,3];</div></pre></td></tr></table></figure>
<p><img src="https://segmentfault.com/img/bVc6E9" alt="img"></p>
<p>array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array1.push(4);</div></pre></td></tr></table></figure>
<p><code>push</code>这个方法来自于array1的<code>__proto__</code>成员指向对象的一个方法<code>(Array.prototye.push())</code>。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象(Array.prototype)的_<code>_proto__</code>成员，才使得这些数组对象可以使用push,reverse等方法。</p>
<h2 id="函数对象实例"><a href="#函数对象实例" class="headerlink" title="函数对象实例"></a>函数对象实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Base() &#123;  </div><div class="line">    this.id = &quot;base&quot; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://segmentfault.com/img/bVc6Fp" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var obj = new Base();</div></pre></td></tr></table></figure>
<p>这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是：</p>
<p><img src="https://segmentfault.com/img/bVc6Fq" alt="img"></p>
<p>new操作符具体干了什么呢?其实很简单，就干了三件事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;;  </div><div class="line">obj.__proto__ = Base.prototype;  </div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>原型链：</strong>当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的<code>prototype</code>对象那里寻找，如果<code>prototype</code>没有，就会去<code>prototype</code>关联的前辈<code>prototype</code>那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为<code>undefined</code>（Object的Prototype就是<code>undefined</code>）从而形成了所谓的“<strong>原型链</strong>”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Shape()&#123;</div><div class="line">        this.name = &quot;shape&quot;;</div><div class="line">        this.toString = function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function TwoShape()&#123;</div><div class="line">        this.name = &quot;2 shape&quot;;</div><div class="line">    &#125;</div><div class="line">    function Triangle(side,height)&#123;</div><div class="line">        this.name = &quot;Triangle&quot;;</div><div class="line">        this.side = side;</div><div class="line">        this.height = height;</div><div class="line">        this.getArea = function()&#123;</div><div class="line">            return this.side*this.height/2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TwoShape.prototype = new Shape();</div><div class="line">    Triangle.prototype = new TwoShape();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里，用构造器Shape()新建了一个实体，然后用它去覆盖该对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Shape()&#123;</div><div class="line">        this.name = &quot;shape&quot;;</div><div class="line">        this.toString = function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function TwoShape()&#123;</div><div class="line">        this.name = &quot;2 shape&quot;;</div><div class="line">    &#125;</div><div class="line">    function Triangle(side,height)&#123;</div><div class="line">        this.name = &quot;Triangle&quot;;</div><div class="line">        this.side = side;</div><div class="line">        this.height = height;</div><div class="line">        this.getArea = function()&#123;</div><div class="line">            return this.side*this.height/2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TwoShape.prototype = new Shape();</div><div class="line">    Triangle.prototype = new TwoShape();</div><div class="line">    </div><div class="line">    TwoShape.prototype.constructor = TwoShape;</div><div class="line">    Triangle.prototype.constructor = Triangle;</div><div class="line">    </div><div class="line">    var my = new Triangle(5,10);</div><div class="line">    my.getArea();</div><div class="line">    my.toString();//Triangle</div><div class="line">    my.constructor;//Triangle(side,height)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p><strong>原型继承：</strong><br>在原型链的末端，就是<code>Object</code>构造函数<code>prototype</code>属性指向的那个原型对象。这个原型对象是所有对象的祖先，这个老祖宗实现了诸如<code>toString</code>等所有对象天生就该具有的方法。其他内置构造函数，如<code>Function，Boolean，String，Date</code>和<code>RegExp</code>等的<code>prototype</code>都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。</p>
<p><code>ECMAScript</code>中，实现继承的方法就是依靠原型链实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Father()&#123;             //被继承的函数叫做超类型（父类，基类）</div><div class="line">    this.name = &quot;Jack&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Son()&#123;          //继承的函数叫做子类型（子类，派生类）</div><div class="line">    this.age = 10;</div><div class="line">&#125;</div><div class="line">//通过原型链继承，赋值给子类型的原型属性</div><div class="line">//new Father()会将father构造里的信息和原型里的信息都交给Son</div><div class="line"></div><div class="line">Son.prototype = new Father();//Son继承了Father,通过原型，形成链条</div><div class="line"></div><div class="line">var son = new Son();</div><div class="line">alert(son.name);//弹出 Jack</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>原型链的问题：原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中最主要的问题来自包含引用类型的值原型。包含引用类型的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上回变成另一个类型的实例。于是，原先的实例属性也就变成了原型的属性。</p>
<p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。再加上刚刚讨论的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。</p>
<p><strong>再举个栗子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Person(name)</div><div class="line">    &#123;</div><div class="line">        this.name = name;//设置对象属性</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    Person.prototype.company = &quot;Microsoft&quot;;//设置原型的属性</div><div class="line">    Person.prototype.SayHello = function() //原型的方法</div><div class="line">    &#123;  </div><div class="line">        alert(&quot;Hello,I&apos;m &quot;+ this.name+ &quot; of &quot; + this.company);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    var BillGates = new Person(&quot;BillGates&quot;);//创建person对象</div><div class="line">    BillGates.SayHello();//继承了原型的内容，输出&quot;Hello,I&apos;m BillGates of Microsoft&quot;</div><div class="line">    </div><div class="line">    var Jobs = new Person(&quot;Jobs&quot;);</div><div class="line">    Jobs.company = &quot;Apple&quot;;//设置自己的company属性，掩盖了原型的company属性</div><div class="line">    Jobs.SayHello = function()</div><div class="line">    &#123;</div><div class="line">        alert(&quot;Hi,&quot;+this.name + &quot; like &quot; + this.company);</div><div class="line">    &#125;;</div><div class="line">    Jobs.SayHello();//自己覆盖的属性和方法，输出&quot;Hi,Jobs like Apple&quot;</div><div class="line">    BillGates.SayHello();//Jobs的覆盖没有影响原型，BillGates还是照样输出</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="ptoto-属性"><a href="#ptoto-属性" class="headerlink" title="__ptoto__属性"></a><code>__ptoto__</code>属性</h2><p><code>__ptoto__</code>属性（IE浏览器不支持）是实例指向原型对象的一个指针，它的作用就是指向构造函数的原型属性<code>constructor</code>，通过这两个属性，就可以访问原型里的属性和方法了。</p>
<p><code>Javascript</code>中的对象实例本质上是由一系列的<code>属性</code>组成的，在这些属性中，有一个内部的不可见的特殊属性——<code>__proto__</code>，该属性的值指向该对象实例的原型，一个对象实例只拥有一个唯一的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Box()&#123;        //大写，代表构造函数</div><div class="line">        Box.prototype.name = &quot;trigkit4&quot;;//原型属性</div><div class="line">        Box.prototype.age = &quot;21&quot;;</div><div class="line">        Box.prototype.run = function()//原型方法</div><div class="line">        &#123;  </div><div class="line">            return this.name + this.age + &apos;studying&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var box1 = new Box();</div><div class="line">    var box2 = new Box();</div><div class="line">    alert(box1.constructor);//构造属性，可以获取构造函数本身，</div><div class="line">                            //作用是被原型指针定位，然后得到构造函数本身</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="proto-属性和prototype属性的区别"><a href="#proto-属性和prototype属性的区别" class="headerlink" title="__proto__属性和prototype属性的区别"></a><code>__proto__</code>属性和prototype属性的区别</h3><p><code>prototype</code>是<code>function</code>对象中专有的属性。<br><code>__proto__</code>是普通对象的隐式属性，在new的时候，会指向<code>prototype</code>所指的对象；<br><code>__ptoto__</code>实际上是某个实体对象的属性，而<code>prototype</code>则是属于构造函数的属性。<code>__ptoto__</code>只能在学习或调试的环境下使用。</p>
<h2 id="原型模式的执行流程"><a href="#原型模式的执行流程" class="headerlink" title="原型模式的执行流程"></a>原型模式的执行流程</h2><p>1.先查找构造函数实例里的属性或方法，如果有，就立即返回。<br>2.如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回</p>
<h3 id="原型对象的"><a href="#原型对象的" class="headerlink" title="原型对象的"></a>原型对象的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Box()&#123;        //大写，代表构造函数</div><div class="line">        Box.prototype.name = &quot;trigkit4&quot;;//原型属性</div><div class="line">        Box.prototype.age = &quot;21&quot;;</div><div class="line">        Box.prototype.run = function()//原型方法</div><div class="line">        &#123;  </div><div class="line">            return this.name + this.age + &apos;studying&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var box1 = new Box();</div><div class="line">    alert(box1.name);//trigkit4,原型里的值</div><div class="line">    box1.name = &quot;Lee&quot;;</div><div class="line">    alert(box1.name);//Lee,就进原则</div><div class="line">    </div><div class="line">    var box2 = new Box();</div><div class="line">    alert(box2.name);//trigkit4,原型的值，没有被box1修改</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="构造函数的"><a href="#构造函数的" class="headerlink" title="构造函数的"></a>构造函数的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Box()&#123;                   </div><div class="line">        this.name = &quot;Bill&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Box.prototype.name = &quot;trigkit4&quot;;//原型属性</div><div class="line">    Box.prototype.age = &quot;21&quot;;</div><div class="line">    Box.prototype.run = function()//原型方法</div><div class="line">    &#123;  </div><div class="line">            return this.name + this.age + &apos;studying&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var box1 = new Box();</div><div class="line">    alert(box1.name);//Bill,原型里的值</div><div class="line">    box1.name = &quot;Lee&quot;;</div><div class="line">    alert(box1.name);//Lee,就进原则</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>综上，整理一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Person()&#123;&#125;;</div><div class="line">    </div><div class="line">    Person.prototype.name = &quot;trigkit4&quot;;</div><div class="line">    Person.prototype.say = function()&#123;</div><div class="line">        alert(&quot;￼Hi&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var p1 = new Person();//prototype是p1和p2的原型对象</div><div class="line">    var p2 = new Person();//p2为实例化对象，其内部有一个__proto__属性，指向Person的prototype</div><div class="line">    </div><div class="line">    console.log(p1.prototype);//undefined,这个属性是一个对象，访问不到</div><div class="line">    console.log(Person.prototype);//Person</div><div class="line">    console.log(Person.prototype.constructor);//原型对象内部也有一个指针（constructor属性）指向构造函数</div><div class="line">    console.log(p1.__proto__);//这个属性是一个指针指向prototype原型对象</div><div class="line">    p1.say();//实例可以访问到在原型对象上定义的属性和方法</div><div class="line">    </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">构造函数.prototype = 原型对象</div><div class="line">原型对象.constructor = 构造函数(模板)</div><div class="line">原型对象.isPrototypeof(实例对象)   判断实例对象的原型 是不是当前对象</div></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> function createObject(name,age)&#123;</div><div class="line">    var obj = new Object();</div><div class="line">    obj.name = name;</div><div class="line">    obj.age = age;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工厂模式解决了实例化对象大量重复的问题，但还有一个问题，那就是根本无法搞清楚他们到底是哪个对象的实例。<br>使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。</p>
<p>使用构造函数的方法和工厂模式的不同之处在于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.构造函数方法没有显示的创建对象(new Object());</div><div class="line">2.直接将属性和方法赋值给this对象</div><div class="line">3.没有return 语句</div></pre></td></tr></table></figure>
<p>当使用了构造函数，并且<code>new</code> 构造函数()，那么就在后台执行了<code>new Object()</code>；<br>函数体内的<code>this</code>代表了<code>new Object()</code>出来的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.判断属性是在构造函数的实例里，还是在原型里，可以使用`hasOwnProperty()`函数</div><div class="line">2.字面量创建的方式使用constructor属性不会指向实例，而会指向Object，构造函数创建的方式则相反</div><div class="line">为什么指向Object？因为Box.prototype = &#123;&#125;;这种写法其实就是创建了一个新对象。</div><div class="line">而每创建一个函数，就会同时创建它的prototype，这个对象也会自动获取constructor属性</div><div class="line">3.如果是实例方法，不同的实例化，他们的方法地址是不一样的，是唯一的</div><div class="line">4.如果是原型方法，那么他们的地址的共享的</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/15/Javascript基础总结五（原型和原型链）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结四（function）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/10/Javascript基础总结四（function）/">Javascript基础总结四（function）</a>
    </h1>
  

        
        <a href="/2016/03/10/Javascript基础总结四（function）/" class="archive-article-date">
  	<time datetime="2016-03-10T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-10</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p>
</blockquote>
<p><code>js</code> 支持两种函数：一类是语言内部的函数（如<code>eval()</code> ），另一类是自己创建的。</p>
<p>在 <code>JavaScript</code> 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</p>
<p>您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>有如下四种调用<code>js</code>函数的方式：</p>
<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过<code>call()</code>和<code>apply()</code></li>
</ul>
<h2 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 当函数无明确返回值时，返回的值就是`undefined`。</div><div class="line"></div><div class="line">2. 当函数有返回值时，返回值是什么就返回什么。</div></pre></td></tr></table></figure>
<p>我们可以通过使用 <code>return</code> 语句实现将函数返回调用它的地方。</p>
<p>在使用 <code>return</code> 语句时，函数会停止执行，并返回指定的值。</p>
<p>函数通常会返回一个唯一值，那么这个值也可能是另一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //函数表达式</div><div class="line">    var box = function()&#123;</div><div class="line">        var a=1;</div><div class="line">        return function()&#123;</div><div class="line">            alert(a++)</div><div class="line">        &#125;</div><div class="line">            alert(a);//永远不会执行</div><div class="line">    &#125;</div><div class="line">    alert(box());//弹出&quot;function()&#123;alert(a++)&#125;&quot;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在这里，我们只需将返回值赋值给某个变量，然后就可以像使用一般函数那样调用它了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var box = function()&#123;</div><div class="line">        var a=1;</div><div class="line">        return function()&#123;</div><div class="line">            alert(++a)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var newFunc = box();</div><div class="line">    newFunc();//2</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>如果想让返回的函数立即执行，亦可以使用<code>box()()</code>来执行这段代码。</p>
<hr>
<p><code>ECMAScript</code>所有函数的参数都是按值传递的，言下之意就是参数不会按引用传递。</p>
<p>PS：如果存在按引用传递的话，那么函数里的那个变量将会是全局变量，在外部也可以访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（1）值类型：数值、布尔值、null、undefined。</div><div class="line">（2）引用类型：对象、数组、函数。</div></pre></td></tr></table></figure>
<p><code>引用类型值</code>：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象；</p>
<h2 id="创建匿名函数"><a href="#创建匿名函数" class="headerlink" title="创建匿名函数"></a>创建匿名函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function()&#123;</div><div class="line">    return ‘hi’;     //单独的匿名函数是无法运行的，就算能运行也无法调用，因为没有名字</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种匿名函数的用法在<code>JQuery</code>中非常多。直接声明一个匿名函数，立即使用。用匿名函数的好处就是省得定义一个用一次就不用的函数，而且免了命名冲突的问题，<code>js</code>中没有命名空间的概念，因此很容易函数名字冲突，一旦命名冲突以最后声明的为准。</p>
<p>在<code>javascript</code>语言里任何匿名函数都是属于<code>window</code>对象。在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的<code>this</code>指向也是<code>window</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">   console.log(this === window);//true</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><strong>通过自我执行来执行匿名函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//通过自我执行来执行匿名函数</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">  (function ()&#123;         // (匿名函数)()；第一圆括号放匿名函数，第二个圆括号执行</div><div class="line">       alert(&apos;Lee&apos;);</div><div class="line">  &#125;)();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><strong>把匿名函数自我执行的返回值赋给变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//把匿名函数自我执行的返回值赋给变量</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var box =  (function ()&#123;           </div><div class="line">           alert(&apos;Lee&apos;);</div><div class="line">      &#125;)();         //弹出”Lee”；</div><div class="line">    alert(box);   //弹出 undefined</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">var box= (function () &#123;</div><div class="line">    return &apos;hi&apos;;</div><div class="line">&#125;)();</div><div class="line">console.log(box);//hi</div></pre></td></tr></table></figure>
<p><strong>自我执行匿名函数的传参：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//自我执行匿名函数的传参</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    (function (age)&#123;</div><div class="line">         alert(age);</div><div class="line">    &#125;)(100);          //弹出100</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="自执行函数的三种写法"><a href="#自执行函数的三种写法" class="headerlink" title="自执行函数的三种写法"></a>自执行函数的三种写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = function ()&#123;</div><div class="line">    alert(2);</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>另一种语法也可得到同样结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = (function () &#123;</div><div class="line">    console.log(2);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>将函数返回值分配给变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = (function () &#123;</div><div class="line">    return 2;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h2 id="js创建动态函数："><a href="#js创建动态函数：" class="headerlink" title="js创建动态函数："></a><code>js</code>创建动态函数：</h2><p>　　<code>js</code>支持创建动态函数，动态函数必须用<code>Function</code>对象来定义（Function是<code>js</code>中的一个对象，是固定不变的，规定<code>Function</code>对象的”F”必须大写，当是<code>function</code>的时候，我们知道是定义函数的时候所使用的一个关键字：<code>function funName(x，y)</code>，当是<code>Function</code>的时候（F大写的时候），我们知道是<code>js</code>中的对象）</p>
<p>创建动态函数的基本格式：<code>var 变量名 = new Function(&quot;参数1&quot;，&quot;参数2&quot;，&quot;参数n&quot;，&quot;执行语句&quot;);</code></p>
<p><strong>看下面的一段代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var square = new Function (&quot;x&quot;,&quot;y&quot;,&quot;var sum ; sum = x+y;return sum;&quot;);</div><div class="line">    alert(&quot;square(2,3)的结果是：&quot;+square(2,3));  //square(2,3)的结果是：5</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><code>square</code>是动态创建的函数，在<code>Function</code>对象后面的括号里的每一部分内容都必须是字符串形式的，也就是说都必须用引号（””或者是’’）括起来</p>
<p><strong>这段代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var square = new Function (&quot;x&quot;,&quot;y&quot;,&quot;var sum ; sum = x+y;return sum;&quot;);</div></pre></td></tr></table></figure>
<p><strong>和下面这段代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//函数声明</div><div class="line">function square (x,y)&#123;</div><div class="line">      var sum;</div><div class="line">      sum = x+y;</div><div class="line">      return sum;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>是一摸一样的，只不过一个是<code>动态函数</code>，一个是<code>静态函数</code>。<br>我们为什么要把代码分成一小段一小段的代码呢？，把一个字符串分成了若干个独立的字符串的优点就在于我们可以通过修改其中的某些字符串来随时改变函数的作用。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调就是一个函数的调用过程。那么就从理解这个调用过程开始吧。函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。</p>
<p>其实中文也很好理解：回调，回调，就是回头调用的意思。函数a的事先干完，回头再调用函数b。</p>
<p>这里必须清楚一点：函数b是你以参数形式传给函数a的，那么函数b就叫回调函数。</p>
<p>在jquery里的绝大多数效果函数都涉及到callback函数。<a href="http://www.w3school.com.cn/jquery/jquery_ref_effects.asp" target="_blank" rel="external">jquery效果函数</a><br><strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        $(&quot;div&quot;).show(1000,function()&#123;</div><div class="line">            //callback function</div><div class="line">        &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里的<code>callback function</code>换成实例可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    $(&quot;div&quot;).show(1000,function()&#123;</div><div class="line">        console.log(&quot;hello world&quot;)</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><code>Callback</code>实际上是，当一个函数执行完后，现执行的那个函数就是所谓的<code>callback</code>函数。怎么样？很好理解吧……</p>
<h2 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5]</div><div class="line">var a =12;   // 变量：自由的</div><div class="line">arr.a= 5;     //属性：属于一个对象</div><div class="line">function show()     //函数：自由的</div><div class="line">&#123;</div><div class="line">     alert(‘a’);</div><div class="line">&#125;</div><div class="line">arr.fn = function()   //方法：属于一个对象</div><div class="line">&#123;</div><div class="line">     alert(‘b’);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实方法就是函数，只不过方法是有所属的对象。</p>
<p>我们所熟知的，将函数绑定到 <code>click</code> 事件<br><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(selector).click(function)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>function</td>
<td>可选。规定当发生 click 事件时运行的函数.</td>
</tr>
</tbody>
</table>
<p>这种形式在<code>jquery</code>中经常见到。它是将<code>function</code>当做该方法的参数，向该方法添加一个事件处理函数。</p>
<h2 id="js全局函数"><a href="#js全局函数" class="headerlink" title="js全局函数"></a>js全局函数</h2><p>全局函数与内置对象的属性或方法不是一个概念。全局函数它不属于任何一个内置对象。<br>JavaScript 中包含以下 7 个全局函数，用于完成一些常用的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、</div><div class="line">parseInt( )、unescape( )。</div></pre></td></tr></table></figure>
<hr>
<h2 id="函数的几个作用"><a href="#函数的几个作用" class="headerlink" title="函数的几个作用"></a>函数的几个作用</h2><h3 id="作为一个类构造器使用"><a href="#作为一个类构造器使用" class="headerlink" title="作为一个类构造器使用"></a>作为一个类构造器使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Class()&#123;&#125;</div><div class="line">Class.prototype=&#123;&#125;;</div><div class="line">var item=new Class();</div></pre></td></tr></table></figure>
<h3 id="作为闭包使用"><a href="#作为闭包使用" class="headerlink" title="作为闭包使用"></a>作为闭包使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    //独立作用域</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="line">        function Test()&#123;//大写，以区分普通函数</div><div class="line">            this.x = 10;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var obj = new Test();</div><div class="line">        alert(obj.x); //弹出 10；</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>可以使用 <code>new</code> 运算符结合像 <code>Object()</code>、<code>Date()</code> 和 <code>Function()</code> 这样的预定义的构造函数来创建对象并对其初始化。面向对象的编程其强有力的特征是定义自定义构造函数以创建脚本中使用的自定义对象的能力。创建了自定义的构造函数，这样就可以创建具有已定义属性的对象。下面是自定义函数的示例（注意 <code>this</code> 关键字的使用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Circle (xPoint, yPoint, radius) &#123;</div><div class="line">    this.x = xPoint;  // 圆心的 x 坐标。</div><div class="line">    this.y = yPoint;  // 圆心的 y 坐标。</div><div class="line">    this.r = radius;  // 圆的半径。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 Circle 构造函数时，给出圆心点的值和圆的半径（所有这些元素是完全定义一个独特的圆对象所必需的）。结束时 Circle 对象包含三个属性。下面是如何例示 <code>Circle</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var aCircle = new Circle(5, 11, 99);</div></pre></td></tr></table></figure>
<p>使用构造器函数的优点是，它可以根据参数来构造不同的对象。 缺点是构造时每个实例对象都会生成重复调用对象的方法，造成了内存的浪费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function Test(name)&#123;</div><div class="line">        this.occupation = &quot;coder&quot;;</div><div class="line">        this.name = name;</div><div class="line">        this.whoAreYou = function()&#123;</div><div class="line">            return &quot;I&apos;m &quot; + this.name + &quot;and I&apos;m a &quot; + this.occupation;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var obj = new Test(&apos;trigkit4&apos;);//利用同一个构造器创建不同的对象</div><div class="line">    var obj2 = new Test(&apos;student&apos;);</div><div class="line">    </div><div class="line">    obj.whoAreYou();//&quot;I&apos;m trigkit4 and I&apos;m a corder&quot;</div><div class="line">    obj2.whoAreYou();//&quot;I&apos;m student and I&apos;m a corder&quot;     </div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>依照惯例，我们应该将构造器函数的首字母大写，以便显著地区别于一般的函数。</p>
<hr>
<p>以下两种形式的定义函数方式是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var test = function()&#123;</div><div class="line">        alert(&quot;Hello World&quot;);</div><div class="line">    &#125;</div><div class="line">    alert(typeof(test));//output function</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里明确定义了一个变量<code>test</code>，他的初始值被赋予了一个<code>function</code>实体<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function test()&#123;</div><div class="line">        alert(&quot;Hello World&quot;);</div><div class="line">    &#125;</div><div class="line">    alert(typeof(test));//output function</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><br><br>看看下面这种定义式函数形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        function test()&#123;</div><div class="line">            alert(&quot;Hello World&quot;);</div><div class="line">        &#125;;</div><div class="line">        test();//居然输出Hello，很奇怪不是吗？</div><div class="line">        </div><div class="line">        function test()&#123;</div><div class="line">            alert(&quot;Hello&quot;);</div><div class="line">        &#125;;</div><div class="line">        test();//正常滴输出了Hello</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>很显然，第一个函数并没有起到作用，很奇怪不是吗？我们知道，<code>javascript</code>解析引擎并不是一行一行地执行代码，而是一段一段地执行代码。在同一段程序的分析执行中，定义式的函数语句会被优先执行，所以第一个定义的代码逻辑已经被第二个覆盖了，所以两次调用相同函数，只会执行第二个。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>函数在<code>js</code>中不仅是一种语法，也是一个值。也就是说可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另一个函数中。<br>函数的名字实际是看不见的，它仅仅是变量的名字，这个变量指代函数对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     function square(x,y)&#123;</div><div class="line">         return x*y;</div><div class="line">     &#125;</div><div class="line">     var s = square; //s和square指代同一个函数</div><div class="line">     square(2,3);//6</div><div class="line">     s(2,4);//8</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性，当函数作为对象的属性调用时，函数就称为方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     var obj = &#123;square:function(x,y)&#123; //对象直接量</div><div class="line">         return x*y;</div><div class="line">     &#125;&#125;;</div><div class="line">     var ect = obj.square(2,3);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h2><p>每一个函数都包含prototype属性，这个属性指向一个对象的引用，这个对象称为原型对象。<br>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000662547" target="_blank" rel="external">javascript学习总结（五）原型和原型链</a></p>
<h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h2><p><code>apply()</code>函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function.apply(this,[1,2,3])</div></pre></td></tr></table></figure>
<p><code>call()</code>的第一个参数是上下文，后续是实例传入的参数序列，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function.call(this,1,2,3);</div></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>这里的高阶函数可不是高数里的那个高阶函数，所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回新函数</p>
<h2 id="参数arguments"><a href="#参数arguments" class="headerlink" title="参数arguments"></a>参数arguments</h2><p>当函数被调用时，会得到一个免费奉送的参数数组，那就是<code>arguments</code>数组。通过它，函数可以访问所有它被调用时传递给他的参数列表。这使得编写一个无需指定参数个数的函数成为可能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var sum = function()&#123;</div><div class="line">        var i ,sum =0;</div><div class="line">        for(i = 0;i&lt;arguments.length;i+=1)&#123;</div><div class="line">            sum+=arguments[i];</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;;</div><div class="line">    document.writeln(sum(4,5,23,13,35,46,-10));//116</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在<code>ECMAScript</code>中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function add(num1,num2)&#123;</div><div class="line">    num = num1 + num2;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = 12,count = 20;</div><div class="line">alert(add(result,count));//32;命名的参数只提供便利，解析器不会验证命名参数</div></pre></td></tr></table></figure>
<p>实际上，<code>arguments</code>并不是一个真正的数组，它只是一个类数组的对象，它拥有一个<code>length</code>属性，但他缺少所有数组的方法。另外，<code>arguments</code>对象的长度是由传入的参数个数决定的，而不是由定义函数时的命名参数的个数决定的</p>
<p>函数在定义或者声明的时候，所有的参数都是形参，因此，我们可以根据实际情况来命名参数，函数也只有在被调用时才会传入实参。而每个函数在被调用时都会自动取得两个特殊变量：<a href="http://segmentfault.com/blog/trigkit4/1190000000660679" target="_blank" rel="external">this</a> 和 <a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader16" target="_blank" rel="external">arguments</a></p>
<h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><p>函数的递归，即一个函数在通过名字调用自身的情况下构成的：</p>
<p>通过使用<code>argument.callee</code>代替函数名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//arguments.callee是一个指向正在执行的函数的指针</div><div class="line">&lt;script&gt;</div><div class="line">    function factorial(num)&#123;</div><div class="line">        if(num&lt;=1)&#123;</div><div class="line">            return 1;</div><div class="line">        &#125;else&#123;</div><div class="line">            return num*arguments.callee(num-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>最后附上一张前辈总结的思维导图：</p>
<p><img src="http://segmentfault.com/img/bVcV4d" alt="img"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/10/Javascript基础总结四（function）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结三（BOM+DOM）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/08/Javascript基础总结三（BOM+DOM）/">Javascript基础总结三（BOM+DOM）</a>
    </h1>
  

        
        <a href="/2016/03/08/Javascript基础总结三（BOM+DOM）/" class="archive-article-date">
  	<time datetime="2016-03-08T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-08</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h2><p><code>D</code>（文档）可以理解为整个<code>Web</code>加载的网页文档，<code>O</code>（对象）可以理解为类似<code>window</code>对象只来的东西，可以调用属性和方法，这里我们说的是<code>document</code>对象，<code>M</code>（模型）可以理解为网页文档的树形结构，<code>DOM</code>树由节点构成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">节点种类：元素节点、文本节点和属性节点</div></pre></td></tr></table></figure>
<p><code>DOM</code>（文档对象模型）是 <code>HTML</code> 和 <code>XML</code> 的应用程序接口（<code>API</code>）。<code>DOM</code>代表着被加载到浏览器窗口里的当前网页：浏览器向我们提供了当前网页的地图（或者说模型），而我们可以通过<code>js</code>去读取这张地图。</p>
<p><code>BOM</code> 主要处理浏览器窗口和框架，不过通常浏览器特定的 <code>JavaScript</code> 扩展都被看做 BOM 的一部分。这些扩展包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">弹出新的浏览器窗口</div><div class="line">移动、关闭浏览器窗口以及调整窗口大小</div><div class="line">提供 Web 浏览器详细信息的定位对象</div><div class="line">提供用户屏幕分辨率详细信息的屏幕对象</div><div class="line">对 cookie 的支持</div><div class="line">IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</div></pre></td></tr></table></figure>
<p><code>window</code>对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为<code>BOM</code></p>
<p>DOM包含：<code>window</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Window对象包含属性：document、location、navigator、screen、history、frames</div><div class="line"></div><div class="line">Document根节点包含子节点：forms、location、anchors、images、links</div></pre></td></tr></table></figure>
<p>从<code>window.document</code>已然可以看出，<code>DOM</code>的最根本的对象是<code>BOM</code>的<code>window</code>对象的子对象。</p>
<p>区别：<code>DOM</code>描述了处理网页内容的方法和接口，<code>BOM</code>描述了与浏览器进行交互的方法和接口。</p>
<p>根据W3C DOM规范，DOM是HTML与XML的应用编程接口（API），DOM将整个页面映射为一个由层次节点组成的文件。有1级、2级、3级共3个级别。</p>
<p>先来看看下面代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</div><div class="line">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">   &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;</div><div class="line">   &lt;head&gt;</div><div class="line">           &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt;</div><div class="line">           &lt;title&gt;DOM&lt;/title&gt;</div><div class="line">   &lt;/head&gt;</div><div class="line">   &lt;body&gt;</div><div class="line">           &lt;h2&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;javascript DOM&lt;/a&gt;&lt;/h2&gt;</div><div class="line">           &lt;p&gt;对HTML元素进行操作，可添加、改变或移除css样式等&lt;/p&gt;</div><div class="line">           &lt;ul&gt;</div><div class="line">                   &lt;li&gt;Javascript&lt;/li&gt;</div><div class="line">                   &lt;li&gt;DOM&lt;/li&gt;</div><div class="line">                   &lt;li&gt;CSS&lt;/li&gt;</div><div class="line">           &lt;/ul&gt;</div><div class="line">   &lt;/body&gt;</div><div class="line">   &lt;/html&gt;</div></pre></td></tr></table></figure>
<p>将HTML代码分解为DOM节点层次图:</p>
<p><img src="http://segmentfault.com/img/bVcUmB" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> **HTML文档可以说由节点构成的集合，DOM节点有:**</div><div class="line">1. 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。</div><div class="line">2. 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。</div><div class="line">3. 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=&quot;http://www.baidu.com&quot;。</div></pre></td></tr></table></figure>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p><code>W3C</code>提供了比较方便的定位节点的方法和属性，如下所示：<br>| 方法 | 说明 |<br>| ————- |:————-:|<br>| getElementById() | 获取特定ID元素的节点 |<br>| getElementsByTagName() | 获取相同元素的节点列表 |<br>| getElementsByName | 获取相同名称的节点列表 |<br>| getAttribute() | 获取特定元素节点属性的值 |<br>| setAttribute() | 设置特定元素节点属性的值 |<br>| removeAttribute() | 移除特定元素节点属性 |</p>
<h2 id="元素节点属性"><a href="#元素节点属性" class="headerlink" title="元素节点属性"></a>元素节点属性</h2><table>
<thead>
<tr>
<th><em>节点属性</em></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>nodeName</td>
<td>返回一个字符串，其内容是节点的名字</td>
</tr>
<tr>
<td>nodeType</td>
<td>返回一个整数，这个数值代表给定节点的类型</td>
</tr>
<tr>
<td>nodeValue</td>
<td>返回给定节点的当前值</td>
</tr>
</tbody>
</table>
<p><br></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tagName</td>
<td style="text-align:center">获取原酸节点的标签名</td>
</tr>
<tr>
<td>innerHTML</td>
<td style="text-align:center">获取元素节点的内容</td>
</tr>
</tbody>
</table>
<h2 id="遍历节点树"><a href="#遍历节点树" class="headerlink" title="遍历节点树"></a>遍历节点树</h2><table>
<thead>
<tr>
<th><em>遍历节点树</em></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>childNodes</td>
<td>返回一个数组，这个数组由给定元素的子节点构成</td>
</tr>
<tr>
<td>firstChild</td>
<td>返回第一个子节点</td>
</tr>
<tr>
<td>lastChild</td>
<td>返回最后一个子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>返回一个给定节点的父节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>返回给定节点的下一个子节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>返回给定节点的上一个子节点</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><table>
<thead>
<tr>
<th><em>DOM操作</em></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>creatElement(element)</td>
<td>创建一个新的元素节点</td>
</tr>
<tr>
<td>creatTextNode()</td>
<td>创建一个包含给定文本的新文本节点</td>
</tr>
<tr>
<td>appendChild()</td>
<td>指定节点的最后一个节点列表后添加一个新的子节</td>
</tr>
<tr>
<td>insertBefore()</td>
<td>将一个给定节点插入到一个给定元素节点的给定子节点的前面</td>
</tr>
<tr>
<td>removeChild()</td>
<td>从一个给定元素中删除子节点</td>
</tr>
<tr>
<td>replaceChild()</td>
<td>把一个给定父元素里的一个子节点替换为另外一个节点</td>
</tr>
</tbody>
</table>
<p><code>DOM</code>通过创建树来表示文档，描述了处理网页内容的方法和接口，从而使开发者对文档的内容和结构具有空前的控制力，用<code>DOM API</code>可以轻松地删除、添加和替换节点。</p>
<h3 id="1-访问节点"><a href="#1-访问节点" class="headerlink" title="1. 访问节点"></a>1. 访问节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`var oHtml = document.documentElement;`  //返回存在于 XML 以及 HTML 文档中的文档根节点，oHtml包含了一个表示&lt;html /&gt;的HTMLElement对象</div><div class="line">`document.body` //是对 HTML 页面的特殊扩展，提供了对 &lt;body&gt; 标签的直接访问&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;</div><div class="line">`document.getElementById(&quot;ID&quot;)` //通过指定的 ID 来返回元素，getElementById() 无法工作在 XML 中，IE6还会返回name为指定ID的元素</div><div class="line">`document.getElementByName(&quot;name&quot;)`//获取所有name特性等于指定值的元素，不过在IE6和Opera7.5上还会返回id为给定名称的元素且仅检查&lt;input/&gt;和&lt;img/&gt;</div><div class="line">`var x=document.getElementsByTagName(&quot;p&quot;);` //使用指定的标签名返回所有的元素列表NodeList，索引号从0开始。当参数是一个星号的时候，IE6并不返回所有的元素，必须用document.all来替代</div></pre></td></tr></table></figure>
<h3 id="2-Node节点的特性和方法"><a href="#2-Node节点的特性和方法" class="headerlink" title="2. Node节点的特性和方法"></a>2. Node节点的特性和方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">firstChild  //Node，指向在childNodes列表中的第一个节点  </div><div class="line">lastChild  //Node，指向在childNodes列表中的最后一个节点  </div><div class="line">parentNode  //Node，指向父节</div><div class="line">ownerDocument //Document，指向这个节点所属的文档 </div><div class="line">firstChild  //Node，指向在childNodes列表中的第一个节点   </div><div class="line">lastChild  //Node，指向在childNodes列表中的最后一个节点   </div><div class="line">parentNode  //Node，指向父节点   </div><div class="line">childNodes //NodeList，所有子节点的列表  </div><div class="line">previousSibling  /Node，/指向前一个兄弟节点：如果这个节点就是第一个节点，那么该值为 null  </div><div class="line">`nextSibling`  //Node，指向后一个兄弟节点：如果这个节点就是最后一个节点，那么该值为null </div><div class="line">`hasChildNodes()`  //Boolean，当childNodes包含一个或多个节点时，返回真值</div></pre></td></tr></table></figure>
<h3 id="3-DOM事件"><a href="#3-DOM事件" class="headerlink" title="3.DOM事件"></a>3.DOM事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DOM同时两种事件模型：冒泡型事件和捕获型事件  </div><div class="line"> 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标的顺序触发  </div><div class="line"> &lt;body onclick=&quot;handleClick()&quot;&gt;  </div><div class="line">     &lt;div onclick=&quot;handleClick()&quot;&gt;Click Me&lt;/div&gt;  </div><div class="line"> &lt;/body&gt;  </div><div class="line"> 触发的顺序是：div、body、html(IE 6.0和Mozilla 1.0)、document、window(Mozilla 1.0)  </div><div class="line">   </div><div class="line"> 捕获型事件：与冒泡事件相反的过程，事件从最不精确的对象开始触发，然后到最精确  </div><div class="line"> 上面例子触发的顺序是：document、div  </div><div class="line"> DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。</div></pre></td></tr></table></figure>
<h3 id="4-事件处理函数-监听函数"><a href="#4-事件处理函数-监听函数" class="headerlink" title="4.事件处理函数/监听函数"></a>4.事件处理函数/监听函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> **事件处理函数/监听函数**  </div><div class="line">在JavaScript中：  </div><div class="line">var oDiv = document.getElementById(&quot;div1&quot;);  </div><div class="line">oDiv.onclick = function()&#123;  //onclick只能用小写，默认为冒泡型事件  </div><div class="line">    alert(&quot;Clicked!&quot;);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">在HTML中：  </div><div class="line">&lt;div onclick=&quot;javascript: alert(&quot;Clicked!&quot;)&quot;&gt;&lt;/div&gt;  //onclick大小写任意</div></pre></td></tr></table></figure>
<h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><h3 id="attachEvent-和detachEvent"><a href="#attachEvent-和detachEvent" class="headerlink" title="attachEvent()和detachEvent()"></a>attachEvent()和detachEvent()</h3><p>在IE中，每个元素和window对象都有两个方法：<code>attachEvent()和detachEvent()</code>，这两个方法接受两个相同的参数，事件处理程序名称和事件处理程序函数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[object].attachEvent(&quot;name_of_event_handler&quot;,&quot;function_to_attach&quot;)  </div><div class="line">[object].detachEvent(&quot;name_of_event_handler&quot;,&quot;function_to_remove&quot;)  </div><div class="line">var fnClick = function()&#123;  </div><div class="line">    alert(&quot;Clicked!&quot;);  </div><div class="line">&#125;  </div><div class="line">oDiv.attachEvent(&quot;onclick&quot;, fnClick);  //添加事件处理函数  </div><div class="line">oDiv.attachEvent(&quot;onclick&quot;, fnClickAnother);  // 可以添加多个事件处理函数  </div><div class="line">oDiv.detachEvent(&quot;onclick&quot;, fnClick);  //移除事件处理函数</div></pre></td></tr></table></figure>
<p>在使用<code>attachEvent()</code>方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。</p>
<h2 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addHandler()和removeHandler()</div></pre></td></tr></table></figure>
<p><code>addHandler()</code>方法属于一个叫EventUntil()的对象，这两个方法均接受三个相同的参数，要操作的元素，事件名称和事件处理程序函数。</p>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">**事件类型** </div><div class="line">  鼠标事件：click、dbclick、mousedown、mouseup、mouseover、mouseout、mousemove  </div><div class="line">  键盘事件：keydown、keypress、keyup  </div><div class="line">  HTML事件：load、unload、abort、error、select、change、submit、reset、</div><div class="line">resize、scroll、focus、blur</div></pre></td></tr></table></figure>
<h3 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h3><p>执行JavaScript 代码的程序在事件发生时会对事件做出响应。为了响应一个特定事件<br>而被执行的代码称为事件处理器。</p>
<p>在HTML标签中使用事件处理器的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;HTML标签 事件处理器=&quot;JavaScript代码&apos;&apos;&gt;</div></pre></td></tr></table></figure>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><p>事件就是用户或浏览器自身执行的某种动作。比如<code>click,mouseup,keydown,mouseover</code>等都是事件的名字。而响应某个事件的函数就叫事件处理程序（事件监听器），事件处理程序以<code>on</code>开头，因此<code>click</code>的事件处理程序就是<code>onclick</code></p>
<p><img src="http://segmentfault.com/img/bVcV3j" alt="img"></p>
<p><img src="http://segmentfault.com/img/bVcV3h" alt="img"></p>
<h2 id="DOM-0级事件处理程序"><a href="#DOM-0级事件处理程序" class="headerlink" title="DOM 0级事件处理程序"></a>DOM 0级事件处理程序</h2><p>DOM 0级事件处理程序：把一个函数赋值给一个事件的处理程序属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;按钮2&quot; id=&quot;ben2&quot;/&gt;</div><div class="line">          var btn2=document.getElementById(&apos;btn2&apos;);获得btn2按钮对象</div><div class="line">          btn2.onclick            //给btn2添加onclick属性，属性又触发了一个事件处理程序</div><div class="line"></div><div class="line">btn2.onclick=function()&#123;</div><div class="line">&#125;                                        //添加匿名函数</div><div class="line"></div><div class="line">btn2.onclick=null           //删除onclick属性</div></pre></td></tr></table></figure>
<h2 id="如何阻止冒泡？"><a href="#如何阻止冒泡？" class="headerlink" title="如何阻止冒泡？"></a>如何阻止冒泡？</h2><p>阻止冒泡有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e.cancelBubble=true;</div><div class="line">e.stopPropagation();</div><div class="line">return false;</div></pre></td></tr></table></figure>
<h2 id="innerText、innerHTML、outerHTML、outerText"><a href="#innerText、innerHTML、outerHTML、outerText" class="headerlink" title="innerText、innerHTML、outerHTML、outerText"></a>innerText、innerHTML、outerHTML、outerText</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">innerText、innerHTML、outerHTML、outerText</div><div class="line">innerText: 表示起始标签和结束标签之间的文本  </div><div class="line"> innerHTML: 表示元素的所有元素和文本的HTML代码  </div><div class="line"> 如：&lt;div&gt;&lt;b&gt;Hello&lt;/b&gt; world&lt;/div&gt;的innerText为Hello world，innerHTML为Hello  world  </div><div class="line"> outerText: 与前者的区别是替换的是整个目标节点，问题返回和innerText一样的内容  </div><div class="line"> outerHTML: 与前者的区别是替换的是整个目标节点，返回元素完整的HTML代码，包括元素本身</div></pre></td></tr></table></figure>
<h2 id="DOM-2级事件处理程序"><a href="#DOM-2级事件处理程序" class="headerlink" title="DOM 2级事件处理程序"></a>DOM 2级事件处理程序</h2><p>DOM 2级事件定义了两个方法，用于指定和删除事件处理程序的操作。<code>addEventListener()</code>和<code>removeEventListener()</code></p>
<h3 id="addEventListener-和removeEventListener"><a href="#addEventListener-和removeEventListener" class="headerlink" title="addEventListener()和removeEventListener()"></a>addEventListener()和removeEventListener()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">在DOM中，addEventListener()和removeEventListener()用来分配和移除事件处理函数，与IE不同的是，这些方法需要三个参数：事件名称，要分配的函数和处理函数是用于冒泡阶段(false)还是捕获阶段(true)，默认为冒泡阶段false  </div><div class="line"></div><div class="line">[object].addEventListener(&quot;name_of_event&quot;,fnhander,bcapture)  </div><div class="line"></div><div class="line">[object].removeEventListener(&quot;name_of_event&quot;,fnhander,bcapture)  </div><div class="line"></div><div class="line">var fnClick = function()&#123;  </div><div class="line">    alert(&quot;Clicked!&quot;);  </div><div class="line">&#125;  </div><div class="line">oDiv.addEventListener(&quot;onclick&quot;, fnClick, false);  //添加事件处理函数  </div><div class="line"></div><div class="line">oDiv.addEventListener(&quot;onclick&quot;, fnClickAnother, false);  // 与IE一样，可以添加多个事件处理函数  </div><div class="line"></div><div class="line">oDiv.removeEventListener(&quot;onclick&quot;, fnClick, false);  //移除事件处理函数  </div><div class="line"></div><div class="line">如果使用addEventListener()将事件处理函数加入到捕获阶段，则必须在removeEventListener()中指明是捕获阶段，才能正确地将这个事件处理函数删除  </div><div class="line"></div><div class="line">oDiv.onclick = fnClick;  </div><div class="line"></div><div class="line">oDiv.onclick = fnClickAnother;  //使用直接赋值，后续的事件处理函数会覆盖前面的处理函数  </div><div class="line"></div><div class="line">oDiv.onclick = fnClick; </div><div class="line"></div><div class="line">oDiv.addEventListener(&quot;onclick&quot;, fnClickAnother, false);  //会按顺序进行调用，不会覆盖</div></pre></td></tr></table></figure>
<p><strong>一张图了解OUTHTML和innerText、innerHTML：</strong></p>
<p><img src="http://segmentfault.com/img/bVcUm0" alt="img"></p>
<h2 id="DOM基本操作思维导图"><a href="#DOM基本操作思维导图" class="headerlink" title="DOM基本操作思维导图"></a>DOM基本操作思维导图</h2><p><img src="http://segmentfault.com/img/bVcUmP" alt="img"></p>
<p>更详细的XML DOM - Element 对象的属性和方法请访问<a href="http://www.w3school.com.cn/xmldom/dom_element.asp" target="_blank" rel="external">w3cshool</a></p>
<hr>
<h2 id="BOM-部分"><a href="#BOM-部分" class="headerlink" title="BOM 部分"></a>BOM 部分</h2><p><code>BOM</code>的核心是<code>window</code>，而<code>window</code>对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个<code>Global</code>（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以window作为其<code>global</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">window.close();  //关闭窗口  </div><div class="line"></div><div class="line">window.alert(&quot;message&quot;);  //弹出一个具有OK按钮的系统消息框，显示指定的文本 </div><div class="line"></div><div class="line">window.confirm(&quot;Are you sure?&quot;);  //弹出一个具有OK和Cancel按钮的询问对话框，返回一个布尔值  </div><div class="line"></div><div class="line">window.prompt(&quot;What&apos;s your name?&quot;, &quot;Default&quot;);  //提示用户输入信息，接受两个参数，即要显示给用户的文本和文本框中的默认值，将文本框中的值作为函数值返回  </div><div class="line"></div><div class="line">window.status  //可以使状态栏的文本暂时改变  </div><div class="line"></div><div class="line">window.defaultStatus  //默认的状态栏信息，可在用户离开当前页面前一直改变文本  </div><div class="line"></div><div class="line">window.setTimeout(&quot;alert(&apos;xxx&apos;)&quot;, 1000);  //设置在指定的毫秒数后执行指定的代码，接受2个参数，要执行的代码和等待的毫秒数  </div><div class="line"></div><div class="line">window.clearTimeout(&quot;ID&quot;);  //取消还未执行的暂停，将暂停ID传递给它  </div><div class="line"></div><div class="line">window.setInterval(function, 1000);  //无限次地每隔指定的时间段重复一次指定的代码，参数同setTimeout()一样  </div><div class="line"></div><div class="line">window.clearInterval(&quot;ID&quot;);  //取消时间间隔，将间隔ID传递给它  </div><div class="line"></div><div class="line">window.history.go(-1);  //访问浏览器窗口的历史，负数为后退，正数为前进 </div><div class="line"></div><div class="line">window.history.back();  //同上  </div><div class="line"></div><div class="line">window.history.forward();  //同上  </div><div class="line"></div><div class="line">window.history.length  //可以查看历史中的页面数</div></pre></td></tr></table></figure>
<h3 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象  </div><div class="line"></div><div class="line">document.lastModified  //获取最后一次修改页面的日期的字符串表示  </div><div class="line"></div><div class="line">document.referrer  //用于跟踪用户从哪里链接过来的  </div><div class="line"></div><div class="line">document.title  //获取当前页面的标题，可读写  </div><div class="line"></div><div class="line">document.URL  //获取当前页面的URL，可读写  </div><div class="line"></div><div class="line">document.anchors[0]或document.anchors[&quot;anchName&quot;] //访问页面中所有的锚  </div><div class="line"></div><div class="line">document.forms[0]或document.forms[&quot;formName&quot;]  //访问页面中所有的表单  </div><div class="line"></div><div class="line">document.images[0]或document.images[&quot;imgName&quot;]  // 访问页面中所有的图像  </div><div class="line"></div><div class="line">document.links [0]或document.links[&quot;linkName&quot;]  //访问页面中所有的链接 </div><div class="line"></div><div class="line">document.applets [0]或document.applets[&quot;appletName&quot;]  //访问页面中所有的Applet  </div><div class="line"></div><div class="line">document.embeds [0]或document.embeds[&quot;embedName&quot;]  //访问页面中所有的嵌入式对象  </div><div class="line"></div><div class="line">document.write(); 或document.writeln();  //将字符串插入到调用它们的位置</div></pre></td></tr></table></figure>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">location对象：表示载入窗口的URL，也可用window.location引用它  </div><div class="line"></div><div class="line">location.href  //当前载入页面的完整URL，如http://www.somewhere.com/pictures/index.htm  </div><div class="line"></div><div class="line">location.portocol  //URL中使用的协议，即双斜杠之前的部分，如http </div><div class="line"></div><div class="line">location.host  //服务器的名字，如www.wrox.com  </div><div class="line"></div><div class="line">location.hostname  //通常等于host，有时会省略前面的www  </div><div class="line"></div><div class="line">location.port  //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080 </div><div class="line"></div><div class="line">location.pathname  //URL中主机名后的部分，如/pictures/index.htm  </div><div class="line"></div><div class="line">location.search  //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx  </div><div class="line"></div><div class="line">location.hash  //如果URL包含#，返回该符号之后的内容，如#anchor1  </div><div class="line"></div><div class="line">location.assign(&quot;http:www.baidu.com&quot;);  //同location.href，新地址都会被加到浏览器的历史栈中  </div><div class="line"></div><div class="line">location.replace(&quot;http:www.baidu.com&quot;);  //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问  </div><div class="line"></div><div class="line">location.reload(true | false);  //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false</div></pre></td></tr></table></figure>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> `navigator`对象：包含大量有关Web浏览器的信息，在检测浏览器及操作系统上非常有用，也可用window.navigator引用它  </div><div class="line"></div><div class="line">`navigator.appCodeName`  //浏览器代码名的字符串表示  </div><div class="line"></div><div class="line">navigator.appName  //官方浏览器名的字符串表示  </div><div class="line"></div><div class="line">navigator.appVersion  //浏览器版本信息的字符串表示  </div><div class="line"></div><div class="line">navigator.cookieEnabled  //如果启用cookie返回true，否则返回false  </div><div class="line"></div><div class="line">navigator.javaEnabled  //如果启用java返回true，否则返回false  </div><div class="line"></div><div class="line">navigator.platform  //浏览器所在计算机平台的字符串表示  </div><div class="line"></div><div class="line">navigator.plugins  //安装在浏览器中的插件数组  </div><div class="line"></div><div class="line">navigator.taintEnabled  //如果启用了数据污点返回true，否则返回false  </div><div class="line"></div><div class="line">navigator.userAgent  //用户代理头的字符串表示</div></pre></td></tr></table></figure>
<h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">screen对象：用于获取某些关于用户屏幕的信息，也可用window.screen引用它  </div><div class="line"></div><div class="line">screen.width/height  //屏幕的宽度与高度，以像素计  </div><div class="line"></div><div class="line">screen.availWidth/availHeight  //窗口可以使用的屏幕的宽度和高度，以像素计 </div><div class="line"></div><div class="line">screen.colorDepth  //用户表示颜色的位数，大多数系统采用32位  </div><div class="line"></div><div class="line">window.moveTo(0, 0);  </div><div class="line"></div><div class="line">window.resizeTo(screen.availWidth, screen.availHeight);  //填充用户的屏幕</div></pre></td></tr></table></figure>
<h3 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h3><p><img src="http://segmentfault.com/img/bVcUmU" alt="img"></p>
<hr>
<h2 id="BOM和DOM的结构关系示意图"><a href="#BOM和DOM的结构关系示意图" class="headerlink" title="BOM和DOM的结构关系示意图"></a>BOM和DOM的结构关系示意图</h2><p><img src="http://segmentfault.com/img/bVcUmV" alt="img"></p>
<p><br></p>
<h2 id="window对象思维导图"><a href="#window对象思维导图" class="headerlink" title="window对象思维导图"></a>window对象思维导图</h2><p><img src="http://segmentfault.com/img/bVcUmW" alt="img"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/08/Javascript基础总结三（BOM+DOM）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结二（对象+数组）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/Javascript基础总结二（对象+数组）/">Javascript基础总结二（对象+数组）</a>
    </h1>
  

        
        <a href="/2016/03/06/Javascript基础总结二（对象+数组）/" class="archive-article-date">
  	<time datetime="2016-03-06T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对象部分"><a href="#对象部分" class="headerlink" title="对象部分"></a>对象部分</h2><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p><code>Object</code> 是一个无序的集合，可以存放任意类型对象，所有其他对象都继承自这个对象。<br>创建<code>Object</code>类型有两种，一种是使用<code>new</code>运算符，一种是字面量表示法。</p>
<p><strong>1.使用new运算符创建Object</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var obj = new Object();//注意大写，也可以直接写成Object()</div></pre></td></tr></table></figure>
<p>注意，通过<code>new Object()</code> 的写法生成新对象，与字面量的写法 <code>obj = {}</code> 是等价的。</p>
<p><strong>2. 使用字面量方式创建：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    name : &apos;trigkit4&apos;,</div><div class="line">    age : 21</div><div class="line">&#125;;//分号最好加上</div></pre></td></tr></table></figure>
<p>在使用字面量声明<code>Object</code>对象时，不会调用<code>Object()</code>构造函数（FF除外）</p>
<h3 id="Object-prototype对象"><a href="#Object-prototype对象" class="headerlink" title="Object.prototype对象"></a>Object.prototype对象</h3><p>所有构造函数都有一个<code>prototype</code>属性，指向一个原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Object.prototype.print = function()&#123; console.log(this)&#125;;</div><div class="line"></div><div class="line">var obj = new Object();</div><div class="line"></div><div class="line">obj.print() // Object</div></pre></td></tr></table></figure>
<p>实例<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.对象只是一种特殊的数据。对象拥有属性和方法。 JavaScript 是面向对象的语言，但 JavaScript 不使用类。 JavaScript 基于 [prototype][1]，而不是基于类的。</div><div class="line"></div><div class="line">2.属性：是隶属于某个特定对象的变量。方法：是只有某个特定对象才能调用的函数。</div><div class="line"></div><div class="line">3.js对象是属性和方法的集合。一个方法就是一个函数，是对象的成员。属性是一个值或一组值（以数组或对象的形式），是对象的成员。</div><div class="line"></div><div class="line">4.js对象是基于构造器函数的，使用构造器函数创建一个新对象时，就可以说是实例化了一个新对象。属性是构造器函数内部的变量。</div></pre></td></tr></table></figure>
<p>使用构造器函数实例化的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat = new Animal();</div></pre></td></tr></table></figure>
<p><code>Javascript</code>是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //对象是名/值对的集合</div><div class="line">        var browser = &#123;        //对象是由花括号括起来的</div><div class="line">            name:&quot;Firefox&quot;,</div><div class="line">            kernel:&quot;Gecko&quot;</div><div class="line">        &#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//通过点号（.）或“[]”来访问对象的属性</div><div class="line">   browser.name         //&quot;Firefox&quot;</div><div class="line">   browser[&quot;kernel&quot;]    //&quot;Gecko&quot;</div></pre></td></tr></table></figure>
<p>对象（objct）是属性（property）的集合，每个属性都由“名/值对”构成，js同样定义了一个特殊的对象——数组，它是带有编号的值的有序集合。</p>
<p><code>js</code>还定义了一个特殊的对象——<a href="http://segmentfault.com/blog/trigkit4/1190000000660786" target="_blank" rel="external">函数</a>，函数是具有与他相关联的可执行代码的对象，通过调用函数来执行代码，并返回运算结果。</p>
<p>JS中没有[类]<a href="">3</a>，但是它取了一个新的名字叫“<code>原型对象</code>”，因此”类==原型对象”，详情见：<a href="http://segmentfault.com/blog/trigkit4/1190000000725051" target="_blank" rel="external">JavaScript类的写法（一）</a></p>
<h3 id="二：类-原型对象-和对象-实例-的区别与联系"><a href="#二：类-原型对象-和对象-实例-的区别与联系" class="headerlink" title="二：类(原型对象)和对象(实例)的区别与联系"></a>二：类(原型对象)和对象(实例)的区别与联系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.类(原型对象)是抽象，是概念的，代表一类事物。</div><div class="line">2.对象是具体的，实际的，代表一个具体的事物。</div><div class="line">3.类(原型对象)是对象实例的模板，对象实例是类的一个个体。</div></pre></td></tr></table></figure>
<p>一个常见的误解是数字的字面值（literal）不是对象。这是因为 JavaScript 解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。</p>
<p>有很多变通方法可以让数字的字面值看起来像对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2..toString(); // 第二个点号可以正常解析</div><div class="line">2 .toString(); // 注意点号前面的空格</div><div class="line">(2).toString(); // 2先被计算</div></pre></td></tr></table></figure>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>删除属性的唯一方法是使用 delete 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性，而仅仅是移除了属性和值的关联。</p>
<h3 id="JavaScript面向对象三大特征"><a href="#JavaScript面向对象三大特征" class="headerlink" title="JavaScript面向对象三大特征"></a>JavaScript面向对象三大特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">封装：不考虑内部实现，只考虑功能使用</div><div class="line">继承：从已有对象上，继承出新的对象</div><div class="line">多态：所谓多态，就是指一个引用在不同情况下的多种状态，</div></pre></td></tr></table></figure>
<h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>封装就是要把属于同一类事物的共性(包括属性与行为)归到一个类中,以方便使用.比如人这个东东,可用下面的方式封装:</p>
<p>人{</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">年龄(属性一)</div><div class="line">身高(属性二)</div><div class="line">性别(属性三)</div><div class="line"></div><div class="line">做事(行为之一)</div><div class="line">走路(行为之二)</div><div class="line">说话(行为之三)</div></pre></td></tr></table></figure>
<p>}</p>
<p><strong>封装的好处：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">封装保护了内部数据的完整性；</div><div class="line">封装使对象的重构更轻松；</div><div class="line">弱化模块间的耦合，提高对象的可重用性；</div><div class="line">有助于避免命名空间冲突；</div></pre></td></tr></table></figure>
<p><strong>看下面一个例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">           var boy = &#123;&#125;; //创建一个空对象</div><div class="line">                   boy.name = &quot;小明&quot;;//按照原型对象的属性赋值</div><div class="line">                   boy.age = 12;</div><div class="line">                   </div><div class="line">           var girl = &#123;&#125;;</div><div class="line">                   girl.name = &quot;小红&quot;;</div><div class="line">                   girl.age = 10;</div><div class="line">   &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（<code>Constructor</code>）模式。</p>
<p>所谓”<code>构造函数</code>“，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用new运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。</p>
<p>比如<code>boy</code>和<code>girl</code>的<a href="http://segmentfault.com/blog/trigkit4/1190000000662547" target="_blank" rel="external">原型对象</a>现在就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">        function Person(name,age)&#123;</div><div class="line">                this.name = name;</div><div class="line">                this.age = age;</div><div class="line">        &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们现在就可以生成实例对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">        var boy = new Person(&quot;小明&quot;,12)；</div><div class="line">        var girl = new Person(&quot;小红&quot;,10);</div><div class="line">        </div><div class="line">        alert(boy.name);  //小明</div><div class="line">        alert(boy.age);   //12</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这时<code>boy</code>和<code>girl</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(boy.constructor == Person); //true</div><div class="line"></div><div class="line">alert(girl.constructor); //输出整串构造函数代码，自己试试吧</div></pre></td></tr></table></figure>
<p><code>Prototype</code>模式 <code>Javascript</code>规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function Person(name,age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.protype.type = &quot;人类&quot;;</div><div class="line"></div><div class="line">Person.protype.eat = function()&#123;</div><div class="line">        alert(&quot;吃米饭&quot;);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后，生成实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">var boy = new Person(&quot;小明&quot;,&quot;12&quot;);</div><div class="line">var girl = new Person(&quot;小红&quot;,&quot;10&quot;);</div><div class="line"></div><div class="line">alert(boy.type);//人类</div><div class="line">boy.eat();//吃饭</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>方法，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(boy.eat == girl.eat); //true</div></pre></td></tr></table></figure>
<p><strong>原型属性</strong>是一个内置属性，它指定了对象所扩展的构造器函数。<br>下面的代码为<code>Animal</code>构造器函数添加一个新的属性<code>size</code>，这个新属性是<code>cat</code>对象的原型属性。通过使用原型属性，所有扩展<code>Animal</code>构造器函数的对象就可以访问<code>size</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat = new Animal(&quot;feline&quot;,&quot;meow&quot;, &quot;walk/run&quot;);</div><div class="line">cat.prototype.size = &quot;fat&quot;;</div></pre></td></tr></table></figure>
<p>在这种情况下，所有的<code>Animal</code>对象的<code>size</code>属性都是“fat”。原型默认为<code>Object</code>的新实例, 由于仍是对象, 故可以给该对象添加新的属性。就好像<code>style</code>是<code>javascript</code>的一个对象一样，也可以往<code>style</code>后继续添加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        /*定义一个Person类*/</div><div class="line">        function Person(_name,_age,_salary)&#123;</div><div class="line">            //Person类的公开属性，类的公开属性的定义方式是：”this.属性名“</div><div class="line">            this.Name=_name;</div><div class="line">            //Person类的私有属性，类的私有属性的定义方式是：”var 属性名“</div><div class="line">            var Age=_age;</div><div class="line">            var Salary=_salary;</div><div class="line">    </div><div class="line">            //定义Person类的公开方法(特权方法)，类的公开方法的定义方式</div><div class="line">是：”this.functionName=function()&#123;.....&#125;“</div><div class="line">            this.Show=function()&#123;</div><div class="line">   alert(&quot;Age=&quot;+Age+&quot;\t&quot;+&quot;Salary=&quot;+Salary);//在公开方法里面访问类的私有属性是允许的</div><div class="line">            &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>对象在查找某个属性的时候，会首先遍历自身的属性，如果没有则会继续查找<code>[[Prototype]]</code>引用的对象，如果再没有则继续查找<code>[[Prototype]].[[Prototype]]</code>引用的对象，依次类推，直到<code>[[Prototype]].….[[Prototype]]</code>为<code>undefined</code>（<code>Object</code>的<code>[[Prototype]]</code>就是<code>undefined</code>）</p>
<p>简单说就是通过对象的<code>[[Prototype]]</code>保存对另一个对象的引用，通过这个引用往上进行属性的查找，这就是原型链。</p>
<h3 id="null-对象"><a href="#null-对象" class="headerlink" title="null 对象"></a>null 对象</h3><p><code>js</code>给变量赋<code>null</code>值的作用在于：<br>赋值一个空指针，容易让人理解这个变量是准备用来存放对象的。也方便调错</p>
<h3 id="全局的window对象"><a href="#全局的window对象" class="headerlink" title="全局的window对象"></a>全局的window对象</h3><p><code>JavaScript</code>中的任何一个全局函数或变量都是<code>window</code>的属性。<br><code>self</code>对象与<code>window</code>对象完全相同，<code>self</code>通常用于确认就是在当前的窗体内。</p>
<p>　window的主对象主要有如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JavaScript document 对象</div><div class="line">JavaScript frames 对象</div><div class="line">JavaScript history 对象</div><div class="line">JavaScript location 对象</div><div class="line">JavaScript navigator 对象</div><div class="line">JavaScript screen 对象</div></pre></td></tr></table></figure>
<h3 id="几个常用方法"><a href="#几个常用方法" class="headerlink" title="几个常用方法"></a>几个常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">valueof()方法：返回指定对象的原始值</div><div class="line">split() 方法将字符串分割为字符串数组，并返回此数组。</div><div class="line">indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。    </div><div class="line">substring() 方法用于提取字符串中介于两个指定下标之间的字符。</div><div class="line">substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。    </div><div class="line">join()方法用于把数组中的所有元素放入一个字符串。</div><div class="line">arrayObject.join(分隔符)</div><div class="line">reverse() 方法用于颠倒数组中元素的顺序。    </div><div class="line">slice() 方法可从已有的数组中返回选定的元素。</div></pre></td></tr></table></figure>
<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>对象字面量是用于创建包含大量属性的过程，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var company = &#123;</div><div class="line">        name : &quot;Microsoft&quot;,</div><div class="line">        ages : 39,</div><div class="line">        employees : 99000,</div><div class="line">        CEO : &quot;Nadella&quot;</div><div class="line">    &#125;;     </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里需要注意的是属性和属性值以冒号(<code>:</code>)隔开；多个属性用逗号(<code>,</code>)隔开。对象字面量亦可以定义方法，只需在这个对象的属性上写上<code>function</code>就行，这是一个匿名函数，调用它只需要写上他的<code>方法名()</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">var dog = &#123;</div><div class="line">   name:&quot;husky&quot;,</div><div class="line">   age:2,</div><div class="line">   run:function()&#123;</div><div class="line">              return &quot;123&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">alert(dog.run());//如果输入dog.run,那么会弹出它后面的function部分的代码</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="基本值类型包装器"><a href="#基本值类型包装器" class="headerlink" title="基本值类型包装器"></a>基本值类型包装器</h2><p><code>js</code>有五种基本的值类型：<code>number、string、Boolean、null和undefined</code>。除了<code>null和undefined</code>外，其他三个都具有所谓的基本包装对象。可以使用内置构造函数<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>创建包装对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = new Number(10);</div><div class="line">console.log(typeof num);//object</div></pre></td></tr></table></figure>
<h2 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object()方法"></a>Object()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Object() // 返回一个空对象</div><div class="line">Object(undefined) // 返回一个空对象</div><div class="line">Object(null) // 返回一个空对象</div><div class="line"></div><div class="line">Object(1) // 等同于 new Number(1)</div><div class="line">Object(&apos;foo&apos;) // 等同于 new String(&apos;foo&apos;)</div><div class="line">Object(true) // 等同于 new Boolean(true)</div><div class="line"></div><div class="line">Object([]) // 返回原数组</div><div class="line">Object(&#123;&#125;) // 返回原对象</div><div class="line">Object(function()&#123;&#125;) // 返回原函数</div></pre></td></tr></table></figure>
<h2 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h2><h3 id="1-Array-对象"><a href="#1-Array-对象" class="headerlink" title="1.Array 对象"></a>1.Array 对象</h3><p><code>Array</code> 对象：提供对创建任何数据类型的数组的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arrayObj = new Array()</div><div class="line">arrayObj = new Array([size])</div><div class="line">arrayObj = new Array([element0[, element1[, ...[, elementN]]]])</div></pre></td></tr></table></figure>
<p>定义：<code>var arr = [2,3,45,6]; var arr = new Array(2,4,5,7)</code><br>两者是定义没有任何差别，<code>[]</code>的性能高，因为代码短。</p>
<p>使用数组和对象字面量：var aTest = <code>[]</code>；创建数组时，使用数组字面量是个好选择；类似的，对象字面量也可用于节省空间。以下两行是相等的，但是使用对象字面量的更加简短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var oTest = new Object;  //尽量不用</div><div class="line">var oTest = &#123; &#125;;    //最好的选择，或者var 0Test = [ ];</div></pre></td></tr></table></figure>
<p>遍历为了达到遍历数组的最佳性能，推荐使用经典的 <code>for</code> 循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var list = [1, 2, 3, 4, 5, ...... 100000000];</div><div class="line">for(var i = 0, l = list.length; i &lt; l; i++) &#123;</div><div class="line">    console.log(list[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码有一个处理，就是通过 <code>l = list.length</code> 来缓存数组的长度。</p>
<h3 id="Array-构造函数"><a href="#Array-构造函数" class="headerlink" title="Array 构造函数"></a>Array 构造函数</h3><p>由于 <code>Array</code> 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 - <code>[]</code> - 来创建数组。</p>
<p>因此下面的代码将会使人很迷惑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Array(3, 4, 5); // 结果: [3, 4, 5] </div><div class="line">new Array(3) // 结果: []，此数组长度为 3</div></pre></td></tr></table></figure>
<p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>
<h2 id="Array数组的属性"><a href="#Array数组的属性" class="headerlink" title="Array数组的属性"></a>Array数组的属性</h2><p><strong>Array</strong>数组的3个属性：<code>length属性、prototype属性、constructor属性</code></p>
<h3 id="1-length属性"><a href="#1-length属性" class="headerlink" title="1.length属性"></a>1.length属性</h3><p>Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。</p>
<h3 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2.prototype属性"></a>2.prototype属性</h3><p>返回对象类型原型的引用。<code>prototype</code>属性是<code>object</code>共有的。</p>
<p>对于<code>Array</code>数组对象，以以下例子说明<code>prototype</code>属性的用途。<br>给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入<code>Array.prototype</code>，并使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function array_max()  </div><div class="line">&#123;  </div><div class="line">var i,max=this[0];  </div><div class="line">for(i=1;i&lt;this.length;i++)  </div><div class="line">&#123;  </div><div class="line">if(max&lt;this[i])  </div><div class="line">max=this[i];  </div><div class="line">&#125;  </div><div class="line">return max;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">Array.prototype.max=array_max;  </div><div class="line">var x=new Array(1,2,3,4,5,6);  </div><div class="line">var y=x.max();</div></pre></td></tr></table></figure>
<p><em>该代码执行后，y保存数组x中的最大值，或说6。</em></p>
<h3 id="3-constructor属性"><a href="#3-constructor属性" class="headerlink" title="3.constructor属性"></a>3.constructor属性</h3><p>表示创建对象的函数。说明：<code>constructor</code>属性是所有具有<code>prototype</code>的对象的成员。它们包括除<code>Global</code>和<code>Math</code>对象以外的所有<code>JScript</code>固有对象。<code>constructor</code>属性保存了对构造特定对象实例的函数的引用。</p>
<p><strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x = new String(&quot;Hi&quot;);  </div><div class="line">if(x.constructor==String) //进行处理（条件为真）。  </div><div class="line">//或  </div><div class="line">function MyFunc&#123;  </div><div class="line">//函数体。  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">y=new MyFunc;  </div><div class="line">if(y.constructor==MyFunc)//进行处理（条件为真）。</div></pre></td></tr></table></figure>
<p><strong>对于数组来说：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y = new Array();</div></pre></td></tr></table></figure>
<h2 id="Array-对象方法"><a href="#Array-对象方法" class="headerlink" title="Array 对象方法"></a>Array 对象方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>concat()</td>
<td>连接两个或更多的数组，并返回结果。</td>
</tr>
<tr>
<td>join()</td>
<td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除并返回数组的最后一个元素</td>
</tr>
<tr>
<td>push()</td>
<td>向数组的末尾添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除并返回数组的第一个元素</td>
</tr>
<tr>
<td>slice()</td>
<td>从某个已有的数组返回选定的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序</td>
</tr>
<tr>
<td>splice()</td>
<td>删除元素，并向数组添加新元素。</td>
</tr>
<tr>
<td>toSource()</td>
<td>返回该对象的源代码。</td>
</tr>
<tr>
<td>toString()</td>
<td>把数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>把数组转换为本地数组，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>向数组的开头添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组对象的原始值</td>
</tr>
</tbody>
</table>
<h3 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h3><p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayObject.sort(sortby)</div></pre></td></tr></table></figure>
<p><code>sortby</code>可选。规定排序顺序。必须是函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [11,2,28,4,5,1];</div><div class="line">console.log(arr.sort());//return  [1, 11, 2, 28, 4, 5]</div></pre></td></tr></table></figure>
<p>为毛这里的11、28没有按照顺序来排列呢？这是因为不带参数的<code>sort</code>是按照字符编码的顺序进行排序的。<br>那么，如果要让数组元素按照从小到大排序呢？看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [11,2,28,4,5,1];</div><div class="line">    console.log(arr.sort(function(a,b)&#123;</div><div class="line">        return a-b;//return  [1, 2, 4, 5, 11, 28]</div><div class="line">    &#125;));</div></pre></td></tr></table></figure>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</div><div class="line">若 a 等于 b，则返回 0。</div><div class="line">若 a 大于 b，则返回一个大于 0 的值。</div></pre></td></tr></table></figure>
<p><strong>附上一张数组的思维导图：</strong><br><img src="http://segmentfault.com/img/bVcT2R" alt="img"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/06/Javascript基础总结二（对象+数组）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Javascript基础总结一（基本概念）" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/Javascript基础总结一（基本概念）/">Javascript基础总结一（基本概念）</a>
    </h1>
  

        
        <a href="/2016/03/02/Javascript基础总结一（基本概念）/" class="archive-article-date">
  	<time datetime="2016-03-02T12:05:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-03-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##基本概念<br><code>javascript</code>是一门解释型的语言，浏览器充当解释器。<code>js</code>执行时，在同一个作用域内是先解释再执行。解释的时候会编译<code>function</code>和<code>var</code>这两个关键词定义的变量，编译完成后从上往下执行并向变量赋值。</p>
<p>###区分大小写<br><code>ECMASCript</code>中的一切（包括变量，函数名和操作符）都区分大小写。</p>
<p>##1.变量<br>变量在第一次用到时就设置于内存中，便于后来在脚本中引用。使用变量之前先进行声明。可以使用 var 关键字来进行变量声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count, amount, level; <span class="comment">// 用单个 var 关键字声明的多个声明。</span></div></pre></td></tr></table></figure></p>
<p>###变量命名<br>变量名包括全局变量，局部变量，类变量，函数参数等等，他们都属于这一类。</p>
<p>变量命名都以类型前缀+有意义的单词组成，用驼峰式命名法增加变量和函式的可读性。例如：<code>sUserName，nCount。</code></p>
<p><strong>前缀规范：</strong><br>每个局部变量都需要有一个类型前缀，按照类型可以分为：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; s：表示字符串。例如：sName，sHtml；</div><div class="line">&gt; n：表示数字。例如：nPage，nTotal；</div><div class="line">&gt; b：表示逻辑。例如：bChecked，bHasLogin；</div><div class="line">&gt; a：表示数组。例如：aList，aGroup；</div><div class="line">&gt; r：表示正则表达式。例如：rDomain，rEmail；</div><div class="line">&gt; f：表示函数。例如：fGetHtml，fInit；</div><div class="line">&gt; o：表示以上未涉及到的其他对象，例如：oButton，oDate；</div><div class="line">&gt; g：表示全局变量，例如：gUserName，gLoginTime；</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>JScript 是一种区分大小写的语言。创建合法的变量名称应遵循如下规则：</p>
<p>1.注意第一个字符不能是数字。</p>
<p>2.后面可以跟任意字母或数字以及下划线，但不能是空格<br>变量名称一定不能是 保留字。</p>
<p>javascript是一种弱类型语言，JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性。</p>
<p>var是javascript的保留字，表明接下来是变量说明，变量名是用户自定义的标识符，变量之间用逗号分开。</p>
<p>如果声明了一个变量但没有对其赋值，该变量存在，其值为Jscript 值 undefined。</p>
<p>###强制类型转换<br>在 Jscript 中，可以对不同类型的值执行运算，不必担心 JScript 解释器产生异常。相反，JScript 解释器自动将数据类型之一改变（强制转换）为另一种数据类型，然后执行运算。例如：</p>
<blockquote>
<p>运算                         结果</p>
<p>数值与字符串相加    将数值强制转换为字符串。<br>布尔值与字符串相加    将布尔值强制转换为字符串。<br>数值与布尔值相加    将布尔值强制转换为数值。</p>
</blockquote>
<p>要想显式地将字符串转换为整数，使用 parseInt 方法。要想显式地将字符串转换为数字，使用 parseFloat 方法。</p>
<p>JavaScript 变量的生存期：当您在函数内声明了一个变量后，就只能在该函数中访问该变量。当退出该函数后，这个变量会被撤销。这种变量称为本地变量。您可以在不同的函数中使用名称相同的本地变量，这是因为只有声明过变量的函数能够识别其中的每个变量。<br>如果您在函数之外声明了一个变量，则页面上的所有函数都可以访问该变量。这些变量的生存期从声明它们之后开始，在页面关闭时结束。</p>
<p>###js变量思维导图<br><img src="https://raw.githubusercontent.com/guohui8/OnlineAlbum/master/blogImage/articlex.gif" alt="mahua"></p>
<p>##2.js的数据类型<br>jscript 有三种-&gt;主要数据类型、两种-&gt;复合数据类型和两种-&gt;特殊数据类型。</p>
<p>主要（基本）数据类型：字符串、数值、布尔</p>
<p>复合（引用）数据类型：对象、数组</p>
<p>特殊数据类型： null 、undefined</p>
<hr>
<p>字符串数据类型：字符串数据类型用来表示 JScript 中的文本。在js中，虽然双引号（””）和单引号(‘’)均可表示字符串，而且它们几乎没有任何区别。但只使用双引号(“”)来表示字符串被认为是最佳的。<br>一个字符串值是排在一起的一串零或零以上的 Unicode 字符（字母、数字和标点符号）。</p>
<p>###什么是Unicode？<br>Unicode为每个字符都提供了唯一的数值，不管是什么平台、什么程序或什么语言。开发unicode是为了给处理世界上存在的所有字符提供统一的编码。</p>
<p>###数值数据类型<br>我们需要明白一点，JScript 内部将所有的数值表示为浮点值，因此，在 Jscript 中整数和浮点值没有差别。</p>
<p>###Boolean数据类型<br>布尔（逻辑）只能有两个值：true 或 false。</p>
<p>###引用数据类型</p>
<p><code>javascript</code>引用数据类型是保存在堆内存中的对象，<code>JavaScript</code>不允许直接访问堆内存空间中的位置和操作堆内存空间，只能通过操作对象在栈内存中的引用地址。所以引用类型的数据，在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存在堆内存中的对象。下面我们来演示这个引用数据类型赋值过程：</p>
<p><img src="https://raw.githubusercontent.com/guohui8/OnlineAlbum/master/blogImage/010.png" alt=""></p>
<p><strong>基本类型值</strong>指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。<br>而<strong>引用类型值</strong>则是指那些保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。<br>简而言之，<strong>堆内存</strong>存放引用值，<strong>栈内存</strong>存放固定类型值。</p>
<p><img src="https://raw.githubusercontent.com/guohui8/OnlineAlbum/master/blogImage/011.jpg" alt=""></p>
<p>在 <code>ECMAScript</code> 中，变量可以存在两种类型的值，即原始值和引用值。<br>原始值存储在栈（<code>stack</code>）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。引用值存储在堆（<code>heap</code>）中的对象，也就是说，存储在变量处的值是一个指针（<code>point</code>），指向存储对象的内存处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript”&gt;</div><div class="line">var box = new Object();  //创建一个引用类型</div><div class="line">var box = &quot;lee&quot;;   //基本类型值是字符串</div><div class="line">box.age = 23;    //基本类型值添加属性很怪异，因为只有对象才可以添加属性。</div><div class="line">alert(box.age);  //不是引用类型，无法输出；</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="3-JScript-的运算符"><a href="#3-JScript-的运算符" class="headerlink" title="3.JScript 的运算符"></a>3.JScript 的运算符</h2><p>优先级：指运算符的运算顺序，通俗的说就是先计算哪一部分。<br>结合性：同一优先级运算符的计算顺序，通俗的说就是从哪个方向算起，是左到右还是右到左。</p>
<h3 id="数据类型转换和基本包装类型"><a href="#数据类型转换和基本包装类型" class="headerlink" title="数据类型转换和基本包装类型"></a>数据类型转换和基本包装类型</h3><p><code>String()</code> 转换为字符串类型<br><code>Number()</code> 转换为数字类型<br><code>Boolean()</code> 转换为布尔类型</p>
<p><code>parseInt</code>：将字符串转换为整数。从字符串的开头开始解析，在第一个非整数的位置停止解析，并返回前面读到所有的整数。如果字符串不是以整数开头的，将返回NaN。如：parseInt（“150 hi”）返回的值是：150，parseInt(“hi”)返回的值是：NaN。<br><code>parseFloat</code>：将字符串转换为浮点数。 从字符串的开头开始解析，在第一个非整数的位置停止解析，并返回前面读到所有的整数。如果字符串不是以整数开头的，将返回NaN。如：<code>parseFloat(&quot;15.5 hi&quot;) 返回的值是：15.5，parseFloat(&quot;hi 15.5&quot;)返回的值是：NaN。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval：将字符串作为javascript表达式进行计算，并返回执行结果，如果没有结果则返回undefined。</div></pre></td></tr></table></figure>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而能调用一些方法来操作这些数据。基本包装类型包括<code>Boolean</code>、<code>Number</code>和<code>String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var box = &apos;trigkit4&apos;; //字面量</div><div class="line">box.name = &apos;mike&apos;;   //无效属性</div><div class="line">box.age = function () &#123; //无效方法</div><div class="line">    return 22;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//new运算符写法</div><div class="line">var box = new String(&apos;trigkit4&apos;);//new 运算符</div><div class="line">box.name = &apos;mike&apos;;   //有效属性</div><div class="line">box.age = function () &#123; //有效方法</div><div class="line">    return 22;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>String</code>类型包含了三个属性和大量的可用内置方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">属性    描述</div><div class="line">length :返回字符串的字符长度</div><div class="line">Constructor : 返回创建String对象的函数</div><div class="line">prototype : 通过添加属性和方法扩展字符串定义</div></pre></td></tr></table></figure>
<p><img src="http://segmentfault.com/img/bVcTZO" alt="img"></p>
<h2 id="4-js流程控制"><a href="#4-js流程控制" class="headerlink" title="4.js流程控制"></a>4.js流程控制</h2><p>对于js流程控制语句，这里只讲几个比较难懂的。其他不赘述。等下附上一张思维导图。<br>1.for…in 语句对应于一个对象的每个，或一个数组的每个元素，执行一个或多个语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (variable in [object | array])</div><div class="line">statements</div></pre></td></tr></table></figure>
<p>参数：</p>
<p><code>variable</code>：必选项。一个变量，它可以是 object 的任一属性或 array 的任一元素。<br><code>object</code>, <code>array</code>：可选项。要在其上遍历的对象或数组。<br><code>statement</code>：可选项。相对于 object 的每个属性或 array 的每个元素，都要被执行的一个或多个语句。可以是复合语句。</p>
<p>虽然条件控制语句（如if语句）只在执行多条语句的情况下才要求使用代码块（左花括号”{“开头，右花括号”}”结尾）,但最佳实践是始终使用代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(args)</div><div class="line">    alert(args);//容易出错</div><div class="line">    </div><div class="line">if(args)&#123;</div><div class="line">    alert(args);//推荐使用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://segmentfault.com/img/bVcTZY" alt="img"><br><em>js流程控制语句思维导图</em></p>
<hr>
<h2 id="5-js函数"><a href="#5-js函数" class="headerlink" title="5.js函数"></a>5.js函数</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p>
<p><code>Jscript</code> 支持两种函数：一类是语言内部的函数，另一类是自己创建的。<br><code>JavaScript</code> 函数允许没有参数（但包含参数的小括号不能省略），也可以向函数传递参数供函数使用。</p>
<p>更多关于函数的知识请访问我的另一篇文章：<a href="http://blog.segmentfault.com/trigkit4/1190000000660786" target="_blank" rel="external">javascript学习大总结（四）function函数部分</a></p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">方法——函数：过程、动态的</div><div class="line">属性——变量：状态、静态的</div></pre></td></tr></table></figure>
<p>最后，再附上一张前辈总结的思维导图：<br><img src="http://segmentfault.com/img/bVcT0u" alt="img"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">技术</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/03/02/Javascript基础总结一（基本概念）/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Guohui
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.234bc0.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">技术</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">相册</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://www.alloyteam.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>腾讯AlloyTeam</a>
            </li>
          
            <li class="search-li">
              <a href="http://fex.baidu.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>百度FEX</a>
            </li>
          
            <li class="search-li">
              <a href="http://taobaofed.org/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>淘宝FED</a>
            </li>
          
            <li class="search-li">
              <a href="https://75team.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>奇舞团</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.w3cplus.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>w3cplus</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.daqianduan.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>大前端</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">程序媛鼓励师&lt;br&gt;精神慈善家&lt;br&gt;装逼爱好者</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>